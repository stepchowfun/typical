// This file was automatically generated by Typical 0.0.0.
// Visit https://github.com/stepchowfun/typical for more information.

use std::{
    cmp::min,
    io::{self, BufRead, Error, ErrorKind, Write},
    mem::transmute,
};

const MISSING_FIELDS_ERROR_MESSAGE: &str = "Struct missing one or more required field(s).";

pub trait Serialize {
    fn size(&self) -> usize;

    fn serialize<T: Write>(&self, writer: &mut T) -> io::Result<()>;
}

pub trait Deserialize {
    fn deserialize<T>(reader: &mut T) -> io::Result<Self>
    where
        Self: Sized,
        T: BufRead;
}

fn zigzag_encode(value: i64) -> u64 {
    unsafe { transmute::<i64, u64>(value >> 63) ^ transmute::<i64, u64>(value << 1) }
}

fn zigzag_decode(value: u64) -> i64 {
    unsafe { transmute::<u64, i64>(value >> 1) ^ -transmute::<u64, i64>(value & 1) }
}

fn varint_size_from_value(value: u64) -> usize {
    match value {
        0_u64..=127_u64 => 1,
        128_u64..=16_511_u64 => 2,
        16_512_u64..=2_113_663_u64 => 3,
        2_113_664_u64..=270_549_119_u64 => 4,
        270_549_120_u64..=34_630_287_487_u64 => 5,
        34_630_287_488_u64..=4_432_676_798_591_u64 => 6,
        4_432_676_798_592_u64..=567_382_630_219_903_u64 => 7,
        567_382_630_219_904_u64..=72_624_976_668_147_839_u64 => 8,
        72_624_976_668_147_840_u64..=18_446_744_073_709_551_615_u64 => 9,
    }
}

fn varint_size_from_first_byte(first_byte: u8) -> u32 {
    first_byte.trailing_zeros() + 1
}

fn serialize_varint<T: Write>(mut value: u64, writer: &mut T) -> io::Result<()> {
    match value {
        0_u64..=127_u64 => writer.write_all(&[((value << 1) as u8) | 0b0000_0001]),
        128_u64..=16_511_u64 => {
            value -= 128_u64;
            writer.write_all(&[((value << 2) as u8) | 0b0000_0010, (value >> 6) as u8])
        }
        16_512_u64..=2_113_663_u64 => {
            value -= 16_512_u64;
            writer.write_all(&[
                ((value << 3) as u8) | 0b0000_0100,
                (value >> 5) as u8,
                (value >> 13) as u8,
            ])
        }
        2_113_664_u64..=270_549_119_u64 => {
            value -= 2_113_664_u64;
            writer.write_all(&[
                ((value << 4) as u8) | 0b0000_1000,
                (value >> 4) as u8,
                (value >> 12) as u8,
                (value >> 20) as u8,
            ])
        }
        270_549_120_u64..=34_630_287_487_u64 => {
            value -= 270_549_120_u64;
            writer.write_all(&[
                ((value << 5) as u8) | 0b0001_0000,
                (value >> 3) as u8,
                (value >> 11) as u8,
                (value >> 19) as u8,
                (value >> 27) as u8,
            ])
        }
        34_630_287_488_u64..=4_432_676_798_591_u64 => {
            value -= 34_630_287_488_u64;
            writer.write_all(&[
                ((value << 6) as u8) | 0b0010_0000,
                (value >> 2) as u8,
                (value >> 10) as u8,
                (value >> 18) as u8,
                (value >> 26) as u8,
                (value >> 34) as u8,
            ])
        }
        4_432_676_798_592_u64..=567_382_630_219_903_u64 => {
            value -= 4_432_676_798_592_u64;
            writer.write_all(&[
                ((value << 7) as u8) | 0b0100_0000,
                (value >> 1) as u8,
                (value >> 9) as u8,
                (value >> 17) as u8,
                (value >> 25) as u8,
                (value >> 33) as u8,
                (value >> 41) as u8,
            ])
        }
        567_382_630_219_904_u64..=72_624_976_668_147_839_u64 => {
            value -= 567_382_630_219_904_u64;
            writer.write_all(&[
                0b1000_0000,
                value as u8,
                (value >> 8) as u8,
                (value >> 16) as u8,
                (value >> 24) as u8,
                (value >> 32) as u8,
                (value >> 40) as u8,
                (value >> 48) as u8,
            ])
        }
        72_624_976_668_147_840_u64..=18_446_744_073_709_551_615_u64 => {
            value -= 72_624_976_668_147_840_u64;
            writer.write_all(&[
                0b0000_0000,
                value as u8,
                (value >> 8) as u8,
                (value >> 16) as u8,
                (value >> 24) as u8,
                (value >> 32) as u8,
                (value >> 40) as u8,
                (value >> 48) as u8,
                (value >> 56) as u8,
            ])
        }
    }
}

fn deserialize_varint<T: BufRead>(reader: &mut T) -> io::Result<u64> {
    let mut first_byte_buffer = [0; 1];
    reader.read_exact(&mut first_byte_buffer[..])?;
    let first_byte = first_byte_buffer[0];
    let size_minus_one = first_byte.trailing_zeros();

    let mut remaining_bytes_buffer = [0; 8];
    reader.read_exact(&mut remaining_bytes_buffer[0..size_minus_one as usize])?;
    let remaining_bytes_value = u64::from_le_bytes(remaining_bytes_buffer);

    match size_minus_one {
        0 => Ok(u64::from(first_byte >> 1)),
        1 => Ok(128_u64 + u64::from(first_byte >> 2) + (remaining_bytes_value << 6)),
        2 => Ok(16_512_u64 + u64::from(first_byte >> 3) + (remaining_bytes_value << 5)),
        3 => Ok(2_113_664_u64 + u64::from(first_byte >> 4) + (remaining_bytes_value << 4)),
        4 => Ok(270_549_120_u64 + u64::from(first_byte >> 5) + (remaining_bytes_value << 3)),
        5 => Ok(34_630_287_488_u64 + u64::from(first_byte >> 6) + (remaining_bytes_value << 2)),
        6 => Ok(4_432_676_798_592_u64 + u64::from(first_byte >> 7) + (remaining_bytes_value << 1)),
        7 => Ok(567_382_630_219_904_u64 + remaining_bytes_value),
        _ => Ok(72_624_976_668_147_840_u64.wrapping_add(remaining_bytes_value)),
    }
}

fn field_header_size(index: u64, payload_size: usize, integer_encoded: bool) -> usize {
    match payload_size {
        0 => varint_size_from_value((index << 2) | 0b00),
        8 => varint_size_from_value((index << 2) | 0b01),
        size => {
            if integer_encoded {
                varint_size_from_value((index << 2) | 0b10)
            } else {
                varint_size_from_value((index << 2) | 0b11) + varint_size_from_value(size as u64)
            }
        }
    }
}

fn serialize_field_header<T: Write>(
    writer: &mut T,
    index: u64,
    payload_size: usize,
    integer_encoded: bool,
) -> io::Result<()> {
    match payload_size {
        0 => serialize_varint((index << 2) | 0b00, writer),
        8 => serialize_varint((index << 2) | 0b01, writer),
        size => {
            if integer_encoded {
                serialize_varint((index << 2) | 0b10, writer)
            } else {
                serialize_varint((index << 2) | 0b11, writer)?;
                serialize_varint(size as u64, writer)
            }
        }
    }
}

fn deserialize_field_header<T: BufRead>(reader: &mut T) -> io::Result<(u64, usize)> {
    let tag = deserialize_varint(&mut *reader)?;

    let index = tag >> 2;

    let size = match tag & 0b11 {
        0b00 => 0,
        0b01 => 8,
        0b10 => {
            let buffer = (&mut *reader).fill_buf()?;

            if buffer.is_empty() {
                return Err(Error::new(
                    ErrorKind::UnexpectedEof,
                    "Error decoding field.",
                ));
            }

            varint_size_from_first_byte(buffer[0]) as usize
        }
        _ => deserialize_varint(&mut *reader)? as usize,
    };

    Ok((index, size))
}

fn skip<T: BufRead>(reader: &mut T, mut amount: usize) -> io::Result<()> {
    while amount > 0 {
        let buffer = reader.fill_buf()?;
        let num_bytes_to_consume = min(buffer.len(), amount);
        reader.consume(num_bytes_to_consume);
        amount -= num_bytes_to_consume;
    }

    Ok(())
}

fn finish<T: BufRead>(reader: &mut T) -> io::Result<()> {
    loop {
        let buffer = reader.fill_buf()?;

        if buffer.is_empty() {
            return Ok(());
        }

        let buffer_size = buffer.len();
        reader.consume(buffer_size);
    }
}

pub mod circular_dependency {
    pub mod dependency {
        pub mod types {
            #[derive(Clone, Debug)]
            pub struct StructFromBelowAtlas {
                pub _size: usize,
                pub x: super::super::types::StructFromAboveAtlas,
            }

            #[derive(Clone, Debug)]
            pub struct StructFromBelowOut {
                pub x: super::super::types::StructFromAboveOut,
            }

            #[derive(Clone, Debug)]
            pub struct StructFromBelowIn {
                pub x: super::super::types::StructFromAboveIn,
            }

            impl super::super::super::Serialize for StructFromBelowOut {
                fn size(&self) -> usize {
                    self.atlas().size()
                }

                fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                    let atlas = self.atlas();
                    self.serialize_with_atlas(writer, &atlas)
                }
            }

            impl super::super::super::Deserialize for StructFromBelowIn {
                fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
                where
                    Self: Sized,
                    T: ::std::io::BufRead,
                {
                    let mut _x: Option<super::super::types::StructFromAboveIn> = None;

                    loop {
                        let (index, payload_size) = match super::super::super::deserialize_field_header(&mut *reader) {
                            Ok(header) => header,
                            Err(err) => {
                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                    break;
                                }

                                return Err(err);
                            }
                        };

                        let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                        match index {
                            0 => {
                                let payload = <super::super::types::StructFromAboveIn as super::super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                _x.get_or_insert(payload);
                            }
                            _ => {
                                super::super::super::skip(&mut sub_reader, payload_size as usize)?;
                            }
                        }
                    }

                    if _x.is_none() {
                        return Err(::std::io::Error::new(
                            ::std::io::ErrorKind::InvalidData,
                            super::super::super::MISSING_FIELDS_ERROR_MESSAGE,
                        ));
                    }

                    Ok(StructFromBelowIn {
                        x: _x.unwrap(),
                    })
                }
            }

            impl From<StructFromBelowOut> for StructFromBelowIn {
                fn from(message: StructFromBelowOut) -> Self {
                    StructFromBelowIn {
                        x: message.x.into(),
                    }
                }
            }

            impl StructFromBelowOut {
                pub fn atlas(&self) -> StructFromBelowAtlas {
                    let _x = { let payload = &self.x; (payload.atlas()) };

                    StructFromBelowAtlas {
                        _size:
                            { let payload_atlas = &_x; let payload_size = payload_atlas.size(); super::super::super::field_header_size(0_u64, payload_size, false) + payload_size },
                        x: _x,
                    }
                }

                pub fn serialize_with_atlas<T: ::std::io::Write>(
                    &self,
                    writer: &mut T,
                    atlas: &StructFromBelowAtlas,
                ) -> ::std::io::Result<()> {
                    {
                        let payload = &self.x;
                        let payload_atlas = &atlas.x;
                        super::super::super::serialize_field_header(writer, 0_u64, payload_atlas.size(), false)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                    }

                    Ok(())
                }
            }

            impl StructFromBelowAtlas {
                pub fn size(&self) -> usize {
                    self._size
                }
            }
        }
    }

    pub mod types {
        #[derive(Clone, Debug)]
        pub struct StructFromAboveAtlas {
            pub _size: usize,
            pub field: usize,
            pub size: usize,
            pub elements: usize,
            pub fallback: usize,
        }

        #[derive(Clone, Debug)]
        pub struct StructFromAboveOut {
            pub field: String,
            pub size: String,
            pub elements: String,
            pub fallback: String,
        }

        #[derive(Clone, Debug)]
        pub struct StructFromAboveIn {
            pub field: String,
            pub size: String,
            pub elements: String,
            pub fallback: String,
        }

        impl super::super::Serialize for StructFromAboveOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for StructFromAboveIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                let mut _field: Option<String> = None;
                let mut _size: Option<String> = None;
                let mut _elements: Option<String> = None;
                let mut _fallback: Option<String> = None;

                loop {
                    let (index, payload_size) = match super::super::deserialize_field_header(&mut *reader) {
                        Ok(header) => header,
                        Err(err) => {
                            if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                break;
                            }

                            return Err(err);
                        }
                    };

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        0 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _field.get_or_insert(payload);
                        }
                        1 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _size.get_or_insert(payload);
                        }
                        2 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _elements.get_or_insert(payload);
                        }
                        3 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _fallback.get_or_insert(payload);
                        }
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }

                if _field.is_none()
                    || _size.is_none()
                    || _elements.is_none()
                    || _fallback.is_none() {
                    return Err(::std::io::Error::new(
                        ::std::io::ErrorKind::InvalidData,
                        super::super::MISSING_FIELDS_ERROR_MESSAGE,
                    ));
                }

                Ok(StructFromAboveIn {
                    field: _field.unwrap(),
                    size: _size.unwrap(),
                    elements: _elements.unwrap(),
                    fallback: _fallback.unwrap(),
                })
            }
        }

        impl From<StructFromAboveOut> for StructFromAboveIn {
            fn from(message: StructFromAboveOut) -> Self {
                StructFromAboveIn {
                    field: message.field.into(),
                    size: message.size.into(),
                    elements: message.elements.into(),
                    fallback: message.fallback.into(),
                }
            }
        }

        impl StructFromAboveOut {
            pub fn atlas(&self) -> StructFromAboveAtlas {
                let _field = { let payload = &self.field; (payload.len()) };
                let _size = { let payload = &self.size; (payload.len()) };
                let _elements = { let payload = &self.elements; (payload.len()) };
                let _fallback = { let payload = &self.fallback; (payload.len()) };

                StructFromAboveAtlas {
                    _size:
                        { let payload_atlas = &_field; let payload_size = *payload_atlas; super::super::field_header_size(0_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_size; let payload_size = *payload_atlas; super::super::field_header_size(1_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_elements; let payload_size = *payload_atlas; super::super::field_header_size(2_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_fallback; let payload_size = *payload_atlas; super::super::field_header_size(3_u64, payload_size, false) + payload_size },
                    field: _field,
                    size: _size,
                    elements: _elements,
                    fallback: _fallback,
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &StructFromAboveAtlas,
            ) -> ::std::io::Result<()> {
                {
                    let payload = &self.field;
                    let payload_atlas = &atlas.field;
                    super::super::serialize_field_header(writer, 0_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.size;
                    let payload_atlas = &atlas.size;
                    super::super::serialize_field_header(writer, 1_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.elements;
                    let payload_atlas = &atlas.elements;
                    super::super::serialize_field_header(writer, 2_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.fallback;
                    let payload_atlas = &atlas.fallback;
                    super::super::serialize_field_header(writer, 3_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                Ok(())
            }
        }

        impl StructFromAboveAtlas {
            pub fn size(&self) -> usize {
                self._size
            }
        }
    }
}

pub mod comprehensive {
    pub mod types {
        #[derive(Clone, Debug)]
        pub struct LocalStructAtlas {
            pub _size: usize,
        }

        #[derive(Clone, Debug)]
        pub struct LocalStructOut {
        }

        #[derive(Clone, Debug)]
        pub struct LocalStructIn {
        }

        impl super::super::Serialize for LocalStructOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for LocalStructIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                loop {
                    let (index, payload_size) = match super::super::deserialize_field_header(&mut *reader) {
                        Ok(header) => header,
                        Err(err) => {
                            if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                break;
                            }

                            return Err(err);
                        }
                    };

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }

                Ok(LocalStructIn {
                })
            }
        }

        impl From<LocalStructOut> for LocalStructIn {
            fn from(message: LocalStructOut) -> Self {
                LocalStructIn {
                }
            }
        }

        impl LocalStructOut {
            pub fn atlas(&self) -> LocalStructAtlas {
                LocalStructAtlas {
                    _size: 0,
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &LocalStructAtlas,
            ) -> ::std::io::Result<()> {
                Ok(())
            }
        }

        impl LocalStructAtlas {
            pub fn size(&self) -> usize {
                self._size
            }
        }

        #[derive(Clone, Debug)]
        pub struct FooAtlas {
            pub _size: usize,
            pub a_required: usize,
            pub b_required: usize,
            pub c_required: usize,
            pub d_required: usize,
            pub e_required: usize,
            pub f_required: usize,
            pub g_required: usize,
            pub h_required: LocalStructAtlas,
            pub i_required: super::super::degenerate::types::EmptyStructAtlas,
            pub j_required: usize,
            pub k_required: usize,
            pub l_required: usize,
            pub m_required: usize,
            pub n_required: usize,
            pub o_required: (usize, Vec<usize>),
            pub p_required: (usize, Vec<usize>),
            pub q_required: (usize, Vec<LocalStructAtlas>),
            pub r_required: (usize, Vec<super::super::degenerate::types::EmptyStructAtlas>),
            pub s_required: (usize, Vec<usize>),
            pub t_required: (usize, Vec<usize>),
            pub u_required: (usize, Vec<usize>),
            pub v_required: (usize, Vec<usize>),
            pub w_required: (usize, Vec<usize>),
            pub x_required: (usize, Vec<(usize, Vec<usize>)>),
            pub y_required: (usize, Vec<(usize, Vec<usize>)>),
            pub z_required: (usize, Vec<(usize, Vec<LocalStructAtlas>)>),
            pub aa_required: (usize, Vec<(usize, Vec<super::super::degenerate::types::EmptyStructAtlas>)>),
            pub a_asymmetric: usize,
            pub b_asymmetric: usize,
            pub c_asymmetric: usize,
            pub d_asymmetric: usize,
            pub e_asymmetric: usize,
            pub f_asymmetric: usize,
            pub g_asymmetric: usize,
            pub h_asymmetric: LocalStructAtlas,
            pub i_asymmetric: super::super::degenerate::types::EmptyStructAtlas,
            pub j_asymmetric: usize,
            pub k_asymmetric: usize,
            pub l_asymmetric: usize,
            pub m_asymmetric: usize,
            pub n_asymmetric: usize,
            pub o_asymmetric: (usize, Vec<usize>),
            pub p_asymmetric: (usize, Vec<usize>),
            pub q_asymmetric: (usize, Vec<LocalStructAtlas>),
            pub r_asymmetric: (usize, Vec<super::super::degenerate::types::EmptyStructAtlas>),
            pub s_asymmetric: (usize, Vec<usize>),
            pub t_asymmetric: (usize, Vec<usize>),
            pub u_asymmetric: (usize, Vec<usize>),
            pub v_asymmetric: (usize, Vec<usize>),
            pub w_asymmetric: (usize, Vec<usize>),
            pub x_asymmetric: (usize, Vec<(usize, Vec<usize>)>),
            pub y_asymmetric: (usize, Vec<(usize, Vec<usize>)>),
            pub z_asymmetric: (usize, Vec<(usize, Vec<LocalStructAtlas>)>),
            pub aa_asymmetric: (usize, Vec<(usize, Vec<super::super::degenerate::types::EmptyStructAtlas>)>),
            pub a_optional: Option<usize>,
            pub b_optional: Option<usize>,
            pub c_optional: Option<usize>,
            pub d_optional: Option<usize>,
            pub e_optional: Option<usize>,
            pub f_optional: Option<usize>,
            pub g_optional: Option<usize>,
            pub h_optional: Option<LocalStructAtlas>,
            pub i_optional: Option<super::super::degenerate::types::EmptyStructAtlas>,
            pub j_optional: Option<usize>,
            pub k_optional: Option<usize>,
            pub l_optional: Option<usize>,
            pub m_optional: Option<usize>,
            pub n_optional: Option<usize>,
            pub o_optional: Option<(usize, Vec<usize>)>,
            pub p_optional: Option<(usize, Vec<usize>)>,
            pub q_optional: Option<(usize, Vec<LocalStructAtlas>)>,
            pub r_optional: Option<(usize, Vec<super::super::degenerate::types::EmptyStructAtlas>)>,
            pub s_optional: Option<(usize, Vec<usize>)>,
            pub t_optional: Option<(usize, Vec<usize>)>,
            pub u_optional: Option<(usize, Vec<usize>)>,
            pub v_optional: Option<(usize, Vec<usize>)>,
            pub w_optional: Option<(usize, Vec<usize>)>,
            pub x_optional: Option<(usize, Vec<(usize, Vec<usize>)>)>,
            pub y_optional: Option<(usize, Vec<(usize, Vec<usize>)>)>,
            pub z_optional: Option<(usize, Vec<(usize, Vec<LocalStructAtlas>)>)>,
            pub aa_optional: Option<(usize, Vec<(usize, Vec<super::super::degenerate::types::EmptyStructAtlas>)>)>,
        }

        #[derive(Clone, Debug)]
        pub struct FooOut {
            pub a_required: (),
            pub b_required: f64,
            pub c_required: u64,
            pub d_required: i64,
            pub e_required: bool,
            pub f_required: Vec<u8>,
            pub g_required: String,
            pub h_required: LocalStructOut,
            pub i_required: super::super::degenerate::types::EmptyStructOut,
            pub j_required: Vec<()>,
            pub k_required: Vec<f64>,
            pub l_required: Vec<u64>,
            pub m_required: Vec<i64>,
            pub n_required: Vec<bool>,
            pub o_required: Vec<Vec<u8>>,
            pub p_required: Vec<String>,
            pub q_required: Vec<LocalStructOut>,
            pub r_required: Vec<super::super::degenerate::types::EmptyStructOut>,
            pub s_required: Vec<Vec<()>>,
            pub t_required: Vec<Vec<f64>>,
            pub u_required: Vec<Vec<u64>>,
            pub v_required: Vec<Vec<i64>>,
            pub w_required: Vec<Vec<bool>>,
            pub x_required: Vec<Vec<Vec<u8>>>,
            pub y_required: Vec<Vec<String>>,
            pub z_required: Vec<Vec<LocalStructOut>>,
            pub aa_required: Vec<Vec<super::super::degenerate::types::EmptyStructOut>>,
            pub a_asymmetric: (),
            pub b_asymmetric: f64,
            pub c_asymmetric: u64,
            pub d_asymmetric: i64,
            pub e_asymmetric: bool,
            pub f_asymmetric: Vec<u8>,
            pub g_asymmetric: String,
            pub h_asymmetric: LocalStructOut,
            pub i_asymmetric: super::super::degenerate::types::EmptyStructOut,
            pub j_asymmetric: Vec<()>,
            pub k_asymmetric: Vec<f64>,
            pub l_asymmetric: Vec<u64>,
            pub m_asymmetric: Vec<i64>,
            pub n_asymmetric: Vec<bool>,
            pub o_asymmetric: Vec<Vec<u8>>,
            pub p_asymmetric: Vec<String>,
            pub q_asymmetric: Vec<LocalStructOut>,
            pub r_asymmetric: Vec<super::super::degenerate::types::EmptyStructOut>,
            pub s_asymmetric: Vec<Vec<()>>,
            pub t_asymmetric: Vec<Vec<f64>>,
            pub u_asymmetric: Vec<Vec<u64>>,
            pub v_asymmetric: Vec<Vec<i64>>,
            pub w_asymmetric: Vec<Vec<bool>>,
            pub x_asymmetric: Vec<Vec<Vec<u8>>>,
            pub y_asymmetric: Vec<Vec<String>>,
            pub z_asymmetric: Vec<Vec<LocalStructOut>>,
            pub aa_asymmetric: Vec<Vec<super::super::degenerate::types::EmptyStructOut>>,
            pub a_optional: Option<()>,
            pub b_optional: Option<f64>,
            pub c_optional: Option<u64>,
            pub d_optional: Option<i64>,
            pub e_optional: Option<bool>,
            pub f_optional: Option<Vec<u8>>,
            pub g_optional: Option<String>,
            pub h_optional: Option<LocalStructOut>,
            pub i_optional: Option<super::super::degenerate::types::EmptyStructOut>,
            pub j_optional: Option<Vec<()>>,
            pub k_optional: Option<Vec<f64>>,
            pub l_optional: Option<Vec<u64>>,
            pub m_optional: Option<Vec<i64>>,
            pub n_optional: Option<Vec<bool>>,
            pub o_optional: Option<Vec<Vec<u8>>>,
            pub p_optional: Option<Vec<String>>,
            pub q_optional: Option<Vec<LocalStructOut>>,
            pub r_optional: Option<Vec<super::super::degenerate::types::EmptyStructOut>>,
            pub s_optional: Option<Vec<Vec<()>>>,
            pub t_optional: Option<Vec<Vec<f64>>>,
            pub u_optional: Option<Vec<Vec<u64>>>,
            pub v_optional: Option<Vec<Vec<i64>>>,
            pub w_optional: Option<Vec<Vec<bool>>>,
            pub x_optional: Option<Vec<Vec<Vec<u8>>>>,
            pub y_optional: Option<Vec<Vec<String>>>,
            pub z_optional: Option<Vec<Vec<LocalStructOut>>>,
            pub aa_optional: Option<Vec<Vec<super::super::degenerate::types::EmptyStructOut>>>,
        }

        #[derive(Clone, Debug)]
        pub struct FooIn {
            pub a_required: (),
            pub b_required: f64,
            pub c_required: u64,
            pub d_required: i64,
            pub e_required: bool,
            pub f_required: Vec<u8>,
            pub g_required: String,
            pub h_required: LocalStructIn,
            pub i_required: super::super::degenerate::types::EmptyStructIn,
            pub j_required: Vec<()>,
            pub k_required: Vec<f64>,
            pub l_required: Vec<u64>,
            pub m_required: Vec<i64>,
            pub n_required: Vec<bool>,
            pub o_required: Vec<Vec<u8>>,
            pub p_required: Vec<String>,
            pub q_required: Vec<LocalStructIn>,
            pub r_required: Vec<super::super::degenerate::types::EmptyStructIn>,
            pub s_required: Vec<Vec<()>>,
            pub t_required: Vec<Vec<f64>>,
            pub u_required: Vec<Vec<u64>>,
            pub v_required: Vec<Vec<i64>>,
            pub w_required: Vec<Vec<bool>>,
            pub x_required: Vec<Vec<Vec<u8>>>,
            pub y_required: Vec<Vec<String>>,
            pub z_required: Vec<Vec<LocalStructIn>>,
            pub aa_required: Vec<Vec<super::super::degenerate::types::EmptyStructIn>>,
            pub a_asymmetric: Option<()>,
            pub b_asymmetric: Option<f64>,
            pub c_asymmetric: Option<u64>,
            pub d_asymmetric: Option<i64>,
            pub e_asymmetric: Option<bool>,
            pub f_asymmetric: Option<Vec<u8>>,
            pub g_asymmetric: Option<String>,
            pub h_asymmetric: Option<LocalStructIn>,
            pub i_asymmetric: Option<super::super::degenerate::types::EmptyStructIn>,
            pub j_asymmetric: Option<Vec<()>>,
            pub k_asymmetric: Option<Vec<f64>>,
            pub l_asymmetric: Option<Vec<u64>>,
            pub m_asymmetric: Option<Vec<i64>>,
            pub n_asymmetric: Option<Vec<bool>>,
            pub o_asymmetric: Option<Vec<Vec<u8>>>,
            pub p_asymmetric: Option<Vec<String>>,
            pub q_asymmetric: Option<Vec<LocalStructIn>>,
            pub r_asymmetric: Option<Vec<super::super::degenerate::types::EmptyStructIn>>,
            pub s_asymmetric: Option<Vec<Vec<()>>>,
            pub t_asymmetric: Option<Vec<Vec<f64>>>,
            pub u_asymmetric: Option<Vec<Vec<u64>>>,
            pub v_asymmetric: Option<Vec<Vec<i64>>>,
            pub w_asymmetric: Option<Vec<Vec<bool>>>,
            pub x_asymmetric: Option<Vec<Vec<Vec<u8>>>>,
            pub y_asymmetric: Option<Vec<Vec<String>>>,
            pub z_asymmetric: Option<Vec<Vec<LocalStructIn>>>,
            pub aa_asymmetric: Option<Vec<Vec<super::super::degenerate::types::EmptyStructIn>>>,
            pub a_optional: Option<()>,
            pub b_optional: Option<f64>,
            pub c_optional: Option<u64>,
            pub d_optional: Option<i64>,
            pub e_optional: Option<bool>,
            pub f_optional: Option<Vec<u8>>,
            pub g_optional: Option<String>,
            pub h_optional: Option<LocalStructIn>,
            pub i_optional: Option<super::super::degenerate::types::EmptyStructIn>,
            pub j_optional: Option<Vec<()>>,
            pub k_optional: Option<Vec<f64>>,
            pub l_optional: Option<Vec<u64>>,
            pub m_optional: Option<Vec<i64>>,
            pub n_optional: Option<Vec<bool>>,
            pub o_optional: Option<Vec<Vec<u8>>>,
            pub p_optional: Option<Vec<String>>,
            pub q_optional: Option<Vec<LocalStructIn>>,
            pub r_optional: Option<Vec<super::super::degenerate::types::EmptyStructIn>>,
            pub s_optional: Option<Vec<Vec<()>>>,
            pub t_optional: Option<Vec<Vec<f64>>>,
            pub u_optional: Option<Vec<Vec<u64>>>,
            pub v_optional: Option<Vec<Vec<i64>>>,
            pub w_optional: Option<Vec<Vec<bool>>>,
            pub x_optional: Option<Vec<Vec<Vec<u8>>>>,
            pub y_optional: Option<Vec<Vec<String>>>,
            pub z_optional: Option<Vec<Vec<LocalStructIn>>>,
            pub aa_optional: Option<Vec<Vec<super::super::degenerate::types::EmptyStructIn>>>,
        }

        impl super::super::Serialize for FooOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for FooIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                let mut _a_required: Option<()> = None;
                let mut _b_required: Option<f64> = None;
                let mut _c_required: Option<u64> = None;
                let mut _d_required: Option<i64> = None;
                let mut _e_required: Option<bool> = None;
                let mut _f_required: Option<Vec<u8>> = None;
                let mut _g_required: Option<String> = None;
                let mut _h_required: Option<LocalStructIn> = None;
                let mut _i_required: Option<super::super::degenerate::types::EmptyStructIn> = None;
                let mut _j_required: Option<Vec<()>> = None;
                let mut _k_required: Option<Vec<f64>> = None;
                let mut _l_required: Option<Vec<u64>> = None;
                let mut _m_required: Option<Vec<i64>> = None;
                let mut _n_required: Option<Vec<bool>> = None;
                let mut _o_required: Option<Vec<Vec<u8>>> = None;
                let mut _p_required: Option<Vec<String>> = None;
                let mut _q_required: Option<Vec<LocalStructIn>> = None;
                let mut _r_required: Option<Vec<super::super::degenerate::types::EmptyStructIn>> = None;
                let mut _s_required: Option<Vec<Vec<()>>> = None;
                let mut _t_required: Option<Vec<Vec<f64>>> = None;
                let mut _u_required: Option<Vec<Vec<u64>>> = None;
                let mut _v_required: Option<Vec<Vec<i64>>> = None;
                let mut _w_required: Option<Vec<Vec<bool>>> = None;
                let mut _x_required: Option<Vec<Vec<Vec<u8>>>> = None;
                let mut _y_required: Option<Vec<Vec<String>>> = None;
                let mut _z_required: Option<Vec<Vec<LocalStructIn>>> = None;
                let mut _aa_required: Option<Vec<Vec<super::super::degenerate::types::EmptyStructIn>>> = None;
                let mut _a_asymmetric: Option<()> = None;
                let mut _b_asymmetric: Option<f64> = None;
                let mut _c_asymmetric: Option<u64> = None;
                let mut _d_asymmetric: Option<i64> = None;
                let mut _e_asymmetric: Option<bool> = None;
                let mut _f_asymmetric: Option<Vec<u8>> = None;
                let mut _g_asymmetric: Option<String> = None;
                let mut _h_asymmetric: Option<LocalStructIn> = None;
                let mut _i_asymmetric: Option<super::super::degenerate::types::EmptyStructIn> = None;
                let mut _j_asymmetric: Option<Vec<()>> = None;
                let mut _k_asymmetric: Option<Vec<f64>> = None;
                let mut _l_asymmetric: Option<Vec<u64>> = None;
                let mut _m_asymmetric: Option<Vec<i64>> = None;
                let mut _n_asymmetric: Option<Vec<bool>> = None;
                let mut _o_asymmetric: Option<Vec<Vec<u8>>> = None;
                let mut _p_asymmetric: Option<Vec<String>> = None;
                let mut _q_asymmetric: Option<Vec<LocalStructIn>> = None;
                let mut _r_asymmetric: Option<Vec<super::super::degenerate::types::EmptyStructIn>> = None;
                let mut _s_asymmetric: Option<Vec<Vec<()>>> = None;
                let mut _t_asymmetric: Option<Vec<Vec<f64>>> = None;
                let mut _u_asymmetric: Option<Vec<Vec<u64>>> = None;
                let mut _v_asymmetric: Option<Vec<Vec<i64>>> = None;
                let mut _w_asymmetric: Option<Vec<Vec<bool>>> = None;
                let mut _x_asymmetric: Option<Vec<Vec<Vec<u8>>>> = None;
                let mut _y_asymmetric: Option<Vec<Vec<String>>> = None;
                let mut _z_asymmetric: Option<Vec<Vec<LocalStructIn>>> = None;
                let mut _aa_asymmetric: Option<Vec<Vec<super::super::degenerate::types::EmptyStructIn>>> = None;
                let mut _a_optional: Option<()> = None;
                let mut _b_optional: Option<f64> = None;
                let mut _c_optional: Option<u64> = None;
                let mut _d_optional: Option<i64> = None;
                let mut _e_optional: Option<bool> = None;
                let mut _f_optional: Option<Vec<u8>> = None;
                let mut _g_optional: Option<String> = None;
                let mut _h_optional: Option<LocalStructIn> = None;
                let mut _i_optional: Option<super::super::degenerate::types::EmptyStructIn> = None;
                let mut _j_optional: Option<Vec<()>> = None;
                let mut _k_optional: Option<Vec<f64>> = None;
                let mut _l_optional: Option<Vec<u64>> = None;
                let mut _m_optional: Option<Vec<i64>> = None;
                let mut _n_optional: Option<Vec<bool>> = None;
                let mut _o_optional: Option<Vec<Vec<u8>>> = None;
                let mut _p_optional: Option<Vec<String>> = None;
                let mut _q_optional: Option<Vec<LocalStructIn>> = None;
                let mut _r_optional: Option<Vec<super::super::degenerate::types::EmptyStructIn>> = None;
                let mut _s_optional: Option<Vec<Vec<()>>> = None;
                let mut _t_optional: Option<Vec<Vec<f64>>> = None;
                let mut _u_optional: Option<Vec<Vec<u64>>> = None;
                let mut _v_optional: Option<Vec<Vec<i64>>> = None;
                let mut _w_optional: Option<Vec<Vec<bool>>> = None;
                let mut _x_optional: Option<Vec<Vec<Vec<u8>>>> = None;
                let mut _y_optional: Option<Vec<Vec<String>>> = None;
                let mut _z_optional: Option<Vec<Vec<LocalStructIn>>> = None;
                let mut _aa_optional: Option<Vec<Vec<super::super::degenerate::types::EmptyStructIn>>> = None;

                loop {
                    let (index, payload_size) = match super::super::deserialize_field_header(&mut *reader) {
                        Ok(header) => header,
                        Err(err) => {
                            if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                break;
                            }

                            return Err(err);
                        }
                    };

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        0 => {
                            let payload = ();
                            _a_required.get_or_insert(payload);
                        }
                        1 => {
                            let payload = if payload_size == 0_usize {
                                0.0_f64
                            } else {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                f64::from_le_bytes(buffer)
                            };
                            _b_required.get_or_insert(payload);
                        }
                        2 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            _c_required.get_or_insert(payload);
                        }
                        3 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = super::super::zigzag_decode(payload);
                            _d_required.get_or_insert(payload);
                        }
                        4 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = payload != 0_u64;
                            _e_required.get_or_insert(payload);
                        }
                        5 => {
                            let mut payload = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                            _f_required.get_or_insert(payload);
                        }
                        6 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _g_required.get_or_insert(payload);
                        }
                        7 => {
                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            _h_required.get_or_insert(payload);
                        }
                        8 => {
                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            _i_required.get_or_insert(payload);
                        }
                        9 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = vec![(); payload as usize];
                            _j_required.get_or_insert(payload);
                        }
                        10 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                let payload = f64::from_le_bytes(buffer);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _k_required.get_or_insert(payload);
                        }
                        11 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _l_required.get_or_insert(payload);
                        }
                        12 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = super::super::zigzag_decode(payload);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _m_required.get_or_insert(payload);
                        }
                        13 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = payload != 0_u64;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _n_required.get_or_insert(payload);
                        }
                        14 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                    payload
                                });
                            }
                            _o_required.get_or_insert(payload);
                        }
                        15 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut buffer = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                    let payload = std::str::from_utf8(&buffer).map_or_else(
                                        |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                        |result| Ok(result.to_owned()),
                                    )?;
                                    payload
                                });
                            }
                            _p_required.get_or_insert(payload);
                        }
                        16 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            _q_required.get_or_insert(payload);
                        }
                        17 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            _r_required.get_or_insert(payload);
                        }
                        18 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                    let payload = vec![(); payload as usize];
                                    payload
                                });
                            }
                            _s_required.get_or_insert(payload);
                        }
                        19 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                        let mut buffer = [0; 8];
                                        ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                        let payload = f64::from_le_bytes(buffer);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _t_required.get_or_insert(payload);
                        }
                        20 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _u_required.get_or_insert(payload);
                        }
                        21 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = super::super::zigzag_decode(payload);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _v_required.get_or_insert(payload);
                        }
                        22 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = payload != 0_u64;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _w_required.get_or_insert(payload);
                        }
                        23 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut payload = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _x_required.get_or_insert(payload);
                        }
                        24 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut buffer = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                                |result| Ok(result.to_owned()),
                                            )?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _y_required.get_or_insert(payload);
                        }
                        25 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _z_required.get_or_insert(payload);
                        }
                        26 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _aa_required.get_or_insert(payload);
                        }
                        28 => {
                            let payload = ();
                            _a_asymmetric.get_or_insert(payload);
                        }
                        29 => {
                            let payload = if payload_size == 0_usize {
                                0.0_f64
                            } else {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                f64::from_le_bytes(buffer)
                            };
                            _b_asymmetric.get_or_insert(payload);
                        }
                        30 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            _c_asymmetric.get_or_insert(payload);
                        }
                        31 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = super::super::zigzag_decode(payload);
                            _d_asymmetric.get_or_insert(payload);
                        }
                        32 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = payload != 0_u64;
                            _e_asymmetric.get_or_insert(payload);
                        }
                        33 => {
                            let mut payload = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                            _f_asymmetric.get_or_insert(payload);
                        }
                        34 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _g_asymmetric.get_or_insert(payload);
                        }
                        35 => {
                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            _h_asymmetric.get_or_insert(payload);
                        }
                        36 => {
                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            _i_asymmetric.get_or_insert(payload);
                        }
                        37 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = vec![(); payload as usize];
                            _j_asymmetric.get_or_insert(payload);
                        }
                        38 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                let payload = f64::from_le_bytes(buffer);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _k_asymmetric.get_or_insert(payload);
                        }
                        39 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _l_asymmetric.get_or_insert(payload);
                        }
                        40 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = super::super::zigzag_decode(payload);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _m_asymmetric.get_or_insert(payload);
                        }
                        41 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = payload != 0_u64;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _n_asymmetric.get_or_insert(payload);
                        }
                        42 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                    payload
                                });
                            }
                            _o_asymmetric.get_or_insert(payload);
                        }
                        43 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut buffer = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                    let payload = std::str::from_utf8(&buffer).map_or_else(
                                        |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                        |result| Ok(result.to_owned()),
                                    )?;
                                    payload
                                });
                            }
                            _p_asymmetric.get_or_insert(payload);
                        }
                        44 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            _q_asymmetric.get_or_insert(payload);
                        }
                        45 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            _r_asymmetric.get_or_insert(payload);
                        }
                        46 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                    let payload = vec![(); payload as usize];
                                    payload
                                });
                            }
                            _s_asymmetric.get_or_insert(payload);
                        }
                        47 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                        let mut buffer = [0; 8];
                                        ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                        let payload = f64::from_le_bytes(buffer);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _t_asymmetric.get_or_insert(payload);
                        }
                        48 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _u_asymmetric.get_or_insert(payload);
                        }
                        49 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = super::super::zigzag_decode(payload);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _v_asymmetric.get_or_insert(payload);
                        }
                        50 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = payload != 0_u64;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _w_asymmetric.get_or_insert(payload);
                        }
                        51 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut payload = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _x_asymmetric.get_or_insert(payload);
                        }
                        52 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut buffer = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                                |result| Ok(result.to_owned()),
                                            )?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _y_asymmetric.get_or_insert(payload);
                        }
                        53 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _z_asymmetric.get_or_insert(payload);
                        }
                        54 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _aa_asymmetric.get_or_insert(payload);
                        }
                        56 => {
                            let payload = ();
                            _a_optional.get_or_insert(payload);
                        }
                        57 => {
                            let payload = if payload_size == 0_usize {
                                0.0_f64
                            } else {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                f64::from_le_bytes(buffer)
                            };
                            _b_optional.get_or_insert(payload);
                        }
                        58 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            _c_optional.get_or_insert(payload);
                        }
                        59 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = super::super::zigzag_decode(payload);
                            _d_optional.get_or_insert(payload);
                        }
                        60 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = payload != 0_u64;
                            _e_optional.get_or_insert(payload);
                        }
                        61 => {
                            let mut payload = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                            _f_optional.get_or_insert(payload);
                        }
                        62 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _g_optional.get_or_insert(payload);
                        }
                        63 => {
                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            _h_optional.get_or_insert(payload);
                        }
                        64 => {
                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            _i_optional.get_or_insert(payload);
                        }
                        65 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = vec![(); payload as usize];
                            _j_optional.get_or_insert(payload);
                        }
                        66 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                let payload = f64::from_le_bytes(buffer);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _k_optional.get_or_insert(payload);
                        }
                        67 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _l_optional.get_or_insert(payload);
                        }
                        68 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = super::super::zigzag_decode(payload);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _m_optional.get_or_insert(payload);
                        }
                        69 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = payload != 0_u64;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            _n_optional.get_or_insert(payload);
                        }
                        70 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                    payload
                                });
                            }
                            _o_optional.get_or_insert(payload);
                        }
                        71 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut buffer = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                    let payload = std::str::from_utf8(&buffer).map_or_else(
                                        |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                        |result| Ok(result.to_owned()),
                                    )?;
                                    payload
                                });
                            }
                            _p_optional.get_or_insert(payload);
                        }
                        72 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            _q_optional.get_or_insert(payload);
                        }
                        73 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            _r_optional.get_or_insert(payload);
                        }
                        74 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                    let payload = vec![(); payload as usize];
                                    payload
                                });
                            }
                            _s_optional.get_or_insert(payload);
                        }
                        75 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                        let mut buffer = [0; 8];
                                        ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                        let payload = f64::from_le_bytes(buffer);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _t_optional.get_or_insert(payload);
                        }
                        76 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _u_optional.get_or_insert(payload);
                        }
                        77 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = super::super::zigzag_decode(payload);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _v_optional.get_or_insert(payload);
                        }
                        78 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = payload != 0_u64;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            _w_optional.get_or_insert(payload);
                        }
                        79 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut payload = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _x_optional.get_or_insert(payload);
                        }
                        80 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut buffer = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                                |result| Ok(result.to_owned()),
                                            )?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _y_optional.get_or_insert(payload);
                        }
                        81 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _z_optional.get_or_insert(payload);
                        }
                        82 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            _aa_optional.get_or_insert(payload);
                        }
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }

                if _a_required.is_none()
                    || _b_required.is_none()
                    || _c_required.is_none()
                    || _d_required.is_none()
                    || _e_required.is_none()
                    || _f_required.is_none()
                    || _g_required.is_none()
                    || _h_required.is_none()
                    || _i_required.is_none()
                    || _j_required.is_none()
                    || _k_required.is_none()
                    || _l_required.is_none()
                    || _m_required.is_none()
                    || _n_required.is_none()
                    || _o_required.is_none()
                    || _p_required.is_none()
                    || _q_required.is_none()
                    || _r_required.is_none()
                    || _s_required.is_none()
                    || _t_required.is_none()
                    || _u_required.is_none()
                    || _v_required.is_none()
                    || _w_required.is_none()
                    || _x_required.is_none()
                    || _y_required.is_none()
                    || _z_required.is_none()
                    || _aa_required.is_none() {
                    return Err(::std::io::Error::new(
                        ::std::io::ErrorKind::InvalidData,
                        super::super::MISSING_FIELDS_ERROR_MESSAGE,
                    ));
                }

                Ok(FooIn {
                    a_required: _a_required.unwrap(),
                    b_required: _b_required.unwrap(),
                    c_required: _c_required.unwrap(),
                    d_required: _d_required.unwrap(),
                    e_required: _e_required.unwrap(),
                    f_required: _f_required.unwrap(),
                    g_required: _g_required.unwrap(),
                    h_required: _h_required.unwrap(),
                    i_required: _i_required.unwrap(),
                    j_required: _j_required.unwrap(),
                    k_required: _k_required.unwrap(),
                    l_required: _l_required.unwrap(),
                    m_required: _m_required.unwrap(),
                    n_required: _n_required.unwrap(),
                    o_required: _o_required.unwrap(),
                    p_required: _p_required.unwrap(),
                    q_required: _q_required.unwrap(),
                    r_required: _r_required.unwrap(),
                    s_required: _s_required.unwrap(),
                    t_required: _t_required.unwrap(),
                    u_required: _u_required.unwrap(),
                    v_required: _v_required.unwrap(),
                    w_required: _w_required.unwrap(),
                    x_required: _x_required.unwrap(),
                    y_required: _y_required.unwrap(),
                    z_required: _z_required.unwrap(),
                    aa_required: _aa_required.unwrap(),
                    a_asymmetric: _a_asymmetric,
                    b_asymmetric: _b_asymmetric,
                    c_asymmetric: _c_asymmetric,
                    d_asymmetric: _d_asymmetric,
                    e_asymmetric: _e_asymmetric,
                    f_asymmetric: _f_asymmetric,
                    g_asymmetric: _g_asymmetric,
                    h_asymmetric: _h_asymmetric,
                    i_asymmetric: _i_asymmetric,
                    j_asymmetric: _j_asymmetric,
                    k_asymmetric: _k_asymmetric,
                    l_asymmetric: _l_asymmetric,
                    m_asymmetric: _m_asymmetric,
                    n_asymmetric: _n_asymmetric,
                    o_asymmetric: _o_asymmetric,
                    p_asymmetric: _p_asymmetric,
                    q_asymmetric: _q_asymmetric,
                    r_asymmetric: _r_asymmetric,
                    s_asymmetric: _s_asymmetric,
                    t_asymmetric: _t_asymmetric,
                    u_asymmetric: _u_asymmetric,
                    v_asymmetric: _v_asymmetric,
                    w_asymmetric: _w_asymmetric,
                    x_asymmetric: _x_asymmetric,
                    y_asymmetric: _y_asymmetric,
                    z_asymmetric: _z_asymmetric,
                    aa_asymmetric: _aa_asymmetric,
                    a_optional: _a_optional,
                    b_optional: _b_optional,
                    c_optional: _c_optional,
                    d_optional: _d_optional,
                    e_optional: _e_optional,
                    f_optional: _f_optional,
                    g_optional: _g_optional,
                    h_optional: _h_optional,
                    i_optional: _i_optional,
                    j_optional: _j_optional,
                    k_optional: _k_optional,
                    l_optional: _l_optional,
                    m_optional: _m_optional,
                    n_optional: _n_optional,
                    o_optional: _o_optional,
                    p_optional: _p_optional,
                    q_optional: _q_optional,
                    r_optional: _r_optional,
                    s_optional: _s_optional,
                    t_optional: _t_optional,
                    u_optional: _u_optional,
                    v_optional: _v_optional,
                    w_optional: _w_optional,
                    x_optional: _x_optional,
                    y_optional: _y_optional,
                    z_optional: _z_optional,
                    aa_optional: _aa_optional,
                })
            }
        }

        impl From<FooOut> for FooIn {
            fn from(message: FooOut) -> Self {
                FooIn {
                    a_required: message.a_required.into(),
                    b_required: message.b_required.into(),
                    c_required: message.c_required.into(),
                    d_required: message.d_required.into(),
                    e_required: message.e_required.into(),
                    f_required: message.f_required.into(),
                    g_required: message.g_required.into(),
                    h_required: message.h_required.into(),
                    i_required: message.i_required.into(),
                    j_required: message.j_required.into(),
                    k_required: message.k_required.into(),
                    l_required: message.l_required.into(),
                    m_required: message.m_required.into(),
                    n_required: message.n_required.into(),
                    o_required: message.o_required.into(),
                    p_required: message.p_required.into(),
                    q_required: message.q_required.into_iter().map(|x| x.into()).collect::<Vec<_>>(),
                    r_required: message.r_required.into_iter().map(|x| x.into()).collect::<Vec<_>>(),
                    s_required: message.s_required.into(),
                    t_required: message.t_required.into(),
                    u_required: message.u_required.into(),
                    v_required: message.v_required.into(),
                    w_required: message.w_required.into(),
                    x_required: message.x_required.into(),
                    y_required: message.y_required.into(),
                    z_required: message.z_required.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>(),
                    aa_required: message.aa_required.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>(),
                    a_asymmetric: Some(message.a_asymmetric.into()),
                    b_asymmetric: Some(message.b_asymmetric.into()),
                    c_asymmetric: Some(message.c_asymmetric.into()),
                    d_asymmetric: Some(message.d_asymmetric.into()),
                    e_asymmetric: Some(message.e_asymmetric.into()),
                    f_asymmetric: Some(message.f_asymmetric.into()),
                    g_asymmetric: Some(message.g_asymmetric.into()),
                    h_asymmetric: Some(message.h_asymmetric.into()),
                    i_asymmetric: Some(message.i_asymmetric.into()),
                    j_asymmetric: Some(message.j_asymmetric.into()),
                    k_asymmetric: Some(message.k_asymmetric.into()),
                    l_asymmetric: Some(message.l_asymmetric.into()),
                    m_asymmetric: Some(message.m_asymmetric.into()),
                    n_asymmetric: Some(message.n_asymmetric.into()),
                    o_asymmetric: Some(message.o_asymmetric.into()),
                    p_asymmetric: Some(message.p_asymmetric.into()),
                    q_asymmetric: Some(message.q_asymmetric.into_iter().map(|x| x.into()).collect::<Vec<_>>()),
                    r_asymmetric: Some(message.r_asymmetric.into_iter().map(|x| x.into()).collect::<Vec<_>>()),
                    s_asymmetric: Some(message.s_asymmetric.into()),
                    t_asymmetric: Some(message.t_asymmetric.into()),
                    u_asymmetric: Some(message.u_asymmetric.into()),
                    v_asymmetric: Some(message.v_asymmetric.into()),
                    w_asymmetric: Some(message.w_asymmetric.into()),
                    x_asymmetric: Some(message.x_asymmetric.into()),
                    y_asymmetric: Some(message.y_asymmetric.into()),
                    z_asymmetric: Some(message.z_asymmetric.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>()),
                    aa_asymmetric: Some(message.aa_asymmetric.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>()),
                    a_optional: message.a_optional.map(|payload| payload.into()),
                    b_optional: message.b_optional.map(|payload| payload.into()),
                    c_optional: message.c_optional.map(|payload| payload.into()),
                    d_optional: message.d_optional.map(|payload| payload.into()),
                    e_optional: message.e_optional.map(|payload| payload.into()),
                    f_optional: message.f_optional.map(|payload| payload.into()),
                    g_optional: message.g_optional.map(|payload| payload.into()),
                    h_optional: message.h_optional.map(|payload| payload.into()),
                    i_optional: message.i_optional.map(|payload| payload.into()),
                    j_optional: message.j_optional.map(|payload| payload.into()),
                    k_optional: message.k_optional.map(|payload| payload.into()),
                    l_optional: message.l_optional.map(|payload| payload.into()),
                    m_optional: message.m_optional.map(|payload| payload.into()),
                    n_optional: message.n_optional.map(|payload| payload.into()),
                    o_optional: message.o_optional.map(|payload| payload.into()),
                    p_optional: message.p_optional.map(|payload| payload.into()),
                    q_optional: message.q_optional.map(|payload| payload.into_iter().map(|x| x.into()).collect::<Vec<_>>()),
                    r_optional: message.r_optional.map(|payload| payload.into_iter().map(|x| x.into()).collect::<Vec<_>>()),
                    s_optional: message.s_optional.map(|payload| payload.into()),
                    t_optional: message.t_optional.map(|payload| payload.into()),
                    u_optional: message.u_optional.map(|payload| payload.into()),
                    v_optional: message.v_optional.map(|payload| payload.into()),
                    w_optional: message.w_optional.map(|payload| payload.into()),
                    x_optional: message.x_optional.map(|payload| payload.into()),
                    y_optional: message.y_optional.map(|payload| payload.into()),
                    z_optional: message.z_optional.map(|payload| payload.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>()),
                    aa_optional: message.aa_optional.map(|payload| payload.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>()),
                }
            }
        }

        impl FooOut {
            pub fn atlas(&self) -> FooAtlas {
                let _a_required = { let payload = &self.a_required; (0_usize) };
                let _b_required = { let payload = &self.b_required; (if payload.to_bits() == 0_u64 { 0_usize } else { 8_usize }) };
                let _c_required = { let payload = &self.c_required; (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) };
                let _d_required = { let payload = &self.d_required; ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) }) };
                let _e_required = { let payload = &self.e_required; (if *payload { 1_usize } else { 0_usize }) };
                let _f_required = { let payload = &self.f_required; (payload.len()) };
                let _g_required = { let payload = &self.g_required; (payload.len()) };
                let _h_required = { let payload = &self.h_required; (payload.atlas()) };
                let _i_required = { let payload = &self.i_required; (payload.atlas()) };
                let _j_required = { let payload = &self.j_required; ({ let payload = &(payload.len() as u64); (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) }) };
                let _k_required = { let payload = &self.k_required; (8_usize * payload.len()) };
                let _l_required = { let payload = &self.l_required; (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload)))) };
                let _m_required = { let payload = &self.m_required; (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) }))) };
                let _n_required = { let payload = &self.n_required; (payload.iter().fold(0_usize, |x, payload| x + (1_usize))) };
                let _o_required = { let payload = &self.o_required; ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _p_required = { let payload = &self.p_required; ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _q_required = { let payload = &self.q_required; ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _r_required = { let payload = &self.r_required; ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _s_required = { let payload = &self.s_required; ({ let atlases = payload.iter().map(|payload| ({ let payload = &(payload.len() as u64); (super::super::varint_size_from_value(*payload)) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _t_required = { let payload = &self.t_required; ({ let atlases = payload.iter().map(|payload| (8_usize * payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _u_required = { let payload = &self.u_required; ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload))))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _v_required = { let payload = &self.v_required; ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) })))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _w_required = { let payload = &self.w_required; ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (1_usize)))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _x_required = { let payload = &self.x_required; ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _y_required = { let payload = &self.y_required; ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _z_required = { let payload = &self.z_required; ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _aa_required = { let payload = &self.aa_required; ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _a_asymmetric = { let payload = &self.a_asymmetric; (0_usize) };
                let _b_asymmetric = { let payload = &self.b_asymmetric; (if payload.to_bits() == 0_u64 { 0_usize } else { 8_usize }) };
                let _c_asymmetric = { let payload = &self.c_asymmetric; (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) };
                let _d_asymmetric = { let payload = &self.d_asymmetric; ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) }) };
                let _e_asymmetric = { let payload = &self.e_asymmetric; (if *payload { 1_usize } else { 0_usize }) };
                let _f_asymmetric = { let payload = &self.f_asymmetric; (payload.len()) };
                let _g_asymmetric = { let payload = &self.g_asymmetric; (payload.len()) };
                let _h_asymmetric = { let payload = &self.h_asymmetric; (payload.atlas()) };
                let _i_asymmetric = { let payload = &self.i_asymmetric; (payload.atlas()) };
                let _j_asymmetric = { let payload = &self.j_asymmetric; ({ let payload = &(payload.len() as u64); (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) }) };
                let _k_asymmetric = { let payload = &self.k_asymmetric; (8_usize * payload.len()) };
                let _l_asymmetric = { let payload = &self.l_asymmetric; (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload)))) };
                let _m_asymmetric = { let payload = &self.m_asymmetric; (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) }))) };
                let _n_asymmetric = { let payload = &self.n_asymmetric; (payload.iter().fold(0_usize, |x, payload| x + (1_usize))) };
                let _o_asymmetric = { let payload = &self.o_asymmetric; ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _p_asymmetric = { let payload = &self.p_asymmetric; ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _q_asymmetric = { let payload = &self.q_asymmetric; ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _r_asymmetric = { let payload = &self.r_asymmetric; ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _s_asymmetric = { let payload = &self.s_asymmetric; ({ let atlases = payload.iter().map(|payload| ({ let payload = &(payload.len() as u64); (super::super::varint_size_from_value(*payload)) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _t_asymmetric = { let payload = &self.t_asymmetric; ({ let atlases = payload.iter().map(|payload| (8_usize * payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _u_asymmetric = { let payload = &self.u_asymmetric; ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload))))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _v_asymmetric = { let payload = &self.v_asymmetric; ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) })))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _w_asymmetric = { let payload = &self.w_asymmetric; ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (1_usize)))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _x_asymmetric = { let payload = &self.x_asymmetric; ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _y_asymmetric = { let payload = &self.y_asymmetric; ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _z_asymmetric = { let payload = &self.z_asymmetric; ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _aa_asymmetric = { let payload = &self.aa_asymmetric; ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }) };
                let _a_optional = self.a_optional.as_ref().map(|payload| (0_usize));
                let _b_optional = self.b_optional.as_ref().map(|payload| (if payload.to_bits() == 0_u64 { 0_usize } else { 8_usize }));
                let _c_optional = self.c_optional.as_ref().map(|payload| (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }));
                let _d_optional = self.d_optional.as_ref().map(|payload| ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) }));
                let _e_optional = self.e_optional.as_ref().map(|payload| (if *payload { 1_usize } else { 0_usize }));
                let _f_optional = self.f_optional.as_ref().map(|payload| (payload.len()));
                let _g_optional = self.g_optional.as_ref().map(|payload| (payload.len()));
                let _h_optional = self.h_optional.as_ref().map(|payload| (payload.atlas()));
                let _i_optional = self.i_optional.as_ref().map(|payload| (payload.atlas()));
                let _j_optional = self.j_optional.as_ref().map(|payload| ({ let payload = &(payload.len() as u64); (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) }));
                let _k_optional = self.k_optional.as_ref().map(|payload| (8_usize * payload.len()));
                let _l_optional = self.l_optional.as_ref().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload)))));
                let _m_optional = self.m_optional.as_ref().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) }))));
                let _n_optional = self.n_optional.as_ref().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (1_usize))));
                let _o_optional = self.o_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _p_optional = self.p_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _q_optional = self.q_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _r_optional = self.r_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _s_optional = self.s_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| ({ let payload = &(payload.len() as u64); (super::super::varint_size_from_value(*payload)) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _t_optional = self.t_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| (8_usize * payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _u_optional = self.u_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload))))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _v_optional = self.v_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) })))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _w_optional = self.w_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (1_usize)))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _x_optional = self.x_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _y_optional = self.y_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _z_optional = self.z_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));
                let _aa_optional = self.aa_optional.as_ref().map(|payload| ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) }));

                FooAtlas {
                    _size:
                        { let payload_atlas = &_a_required; let payload_size = *payload_atlas; super::super::field_header_size(0_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_b_required; let payload_size = *payload_atlas; super::super::field_header_size(1_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_c_required; let payload_size = *payload_atlas; super::super::field_header_size(2_u64, payload_size, true) + payload_size }
                        + { let payload_atlas = &_d_required; let payload_size = *payload_atlas; super::super::field_header_size(3_u64, payload_size, true) + payload_size }
                        + { let payload_atlas = &_e_required; let payload_size = *payload_atlas; super::super::field_header_size(4_u64, payload_size, true) + payload_size }
                        + { let payload_atlas = &_f_required; let payload_size = *payload_atlas; super::super::field_header_size(5_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_g_required; let payload_size = *payload_atlas; super::super::field_header_size(6_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_h_required; let payload_size = payload_atlas.size(); super::super::field_header_size(7_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_i_required; let payload_size = payload_atlas.size(); super::super::field_header_size(8_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_j_required; let payload_size = *payload_atlas; super::super::field_header_size(9_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_k_required; let payload_size = *payload_atlas; super::super::field_header_size(10_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_l_required; let payload_size = *payload_atlas; super::super::field_header_size(11_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_m_required; let payload_size = *payload_atlas; super::super::field_header_size(12_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_n_required; let payload_size = *payload_atlas; super::super::field_header_size(13_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_o_required; let payload_size = payload_atlas.0; super::super::field_header_size(14_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_p_required; let payload_size = payload_atlas.0; super::super::field_header_size(15_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_q_required; let payload_size = payload_atlas.0; super::super::field_header_size(16_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_r_required; let payload_size = payload_atlas.0; super::super::field_header_size(17_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_s_required; let payload_size = payload_atlas.0; super::super::field_header_size(18_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_t_required; let payload_size = payload_atlas.0; super::super::field_header_size(19_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_u_required; let payload_size = payload_atlas.0; super::super::field_header_size(20_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_v_required; let payload_size = payload_atlas.0; super::super::field_header_size(21_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_w_required; let payload_size = payload_atlas.0; super::super::field_header_size(22_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_x_required; let payload_size = payload_atlas.0; super::super::field_header_size(23_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_y_required; let payload_size = payload_atlas.0; super::super::field_header_size(24_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_z_required; let payload_size = payload_atlas.0; super::super::field_header_size(25_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_aa_required; let payload_size = payload_atlas.0; super::super::field_header_size(26_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_a_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(28_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_b_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(29_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_c_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(30_u64, payload_size, true) + payload_size }
                        + { let payload_atlas = &_d_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(31_u64, payload_size, true) + payload_size }
                        + { let payload_atlas = &_e_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(32_u64, payload_size, true) + payload_size }
                        + { let payload_atlas = &_f_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(33_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_g_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(34_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_h_asymmetric; let payload_size = payload_atlas.size(); super::super::field_header_size(35_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_i_asymmetric; let payload_size = payload_atlas.size(); super::super::field_header_size(36_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_j_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(37_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_k_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(38_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_l_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(39_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_m_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(40_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_n_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(41_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_o_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(42_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_p_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(43_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_q_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(44_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_r_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(45_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_s_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(46_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_t_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(47_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_u_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(48_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_v_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(49_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_w_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(50_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_x_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(51_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_y_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(52_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_z_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(53_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_aa_asymmetric; let payload_size = payload_atlas.0; super::super::field_header_size(54_u64, payload_size, false) + payload_size }
                        + _a_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(56_u64, payload_size, false) + payload_size })
                        + _b_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(57_u64, payload_size, false) + payload_size })
                        + _c_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(58_u64, payload_size, true) + payload_size })
                        + _d_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(59_u64, payload_size, true) + payload_size })
                        + _e_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(60_u64, payload_size, true) + payload_size })
                        + _f_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(61_u64, payload_size, false) + payload_size })
                        + _g_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(62_u64, payload_size, false) + payload_size })
                        + _h_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.size(); super::super::field_header_size(63_u64, payload_size, false) + payload_size })
                        + _i_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.size(); super::super::field_header_size(64_u64, payload_size, false) + payload_size })
                        + _j_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(65_u64, payload_size, false) + payload_size })
                        + _k_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(66_u64, payload_size, false) + payload_size })
                        + _l_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(67_u64, payload_size, false) + payload_size })
                        + _m_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(68_u64, payload_size, false) + payload_size })
                        + _n_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(69_u64, payload_size, false) + payload_size })
                        + _o_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(70_u64, payload_size, false) + payload_size })
                        + _p_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(71_u64, payload_size, false) + payload_size })
                        + _q_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(72_u64, payload_size, false) + payload_size })
                        + _r_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(73_u64, payload_size, false) + payload_size })
                        + _s_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(74_u64, payload_size, false) + payload_size })
                        + _t_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(75_u64, payload_size, false) + payload_size })
                        + _u_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(76_u64, payload_size, false) + payload_size })
                        + _v_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(77_u64, payload_size, false) + payload_size })
                        + _w_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(78_u64, payload_size, false) + payload_size })
                        + _x_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(79_u64, payload_size, false) + payload_size })
                        + _y_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(80_u64, payload_size, false) + payload_size })
                        + _z_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(81_u64, payload_size, false) + payload_size })
                        + _aa_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = payload_atlas.0; super::super::field_header_size(82_u64, payload_size, false) + payload_size }),
                    a_required: _a_required,
                    b_required: _b_required,
                    c_required: _c_required,
                    d_required: _d_required,
                    e_required: _e_required,
                    f_required: _f_required,
                    g_required: _g_required,
                    h_required: _h_required,
                    i_required: _i_required,
                    j_required: _j_required,
                    k_required: _k_required,
                    l_required: _l_required,
                    m_required: _m_required,
                    n_required: _n_required,
                    o_required: _o_required,
                    p_required: _p_required,
                    q_required: _q_required,
                    r_required: _r_required,
                    s_required: _s_required,
                    t_required: _t_required,
                    u_required: _u_required,
                    v_required: _v_required,
                    w_required: _w_required,
                    x_required: _x_required,
                    y_required: _y_required,
                    z_required: _z_required,
                    aa_required: _aa_required,
                    a_asymmetric: _a_asymmetric,
                    b_asymmetric: _b_asymmetric,
                    c_asymmetric: _c_asymmetric,
                    d_asymmetric: _d_asymmetric,
                    e_asymmetric: _e_asymmetric,
                    f_asymmetric: _f_asymmetric,
                    g_asymmetric: _g_asymmetric,
                    h_asymmetric: _h_asymmetric,
                    i_asymmetric: _i_asymmetric,
                    j_asymmetric: _j_asymmetric,
                    k_asymmetric: _k_asymmetric,
                    l_asymmetric: _l_asymmetric,
                    m_asymmetric: _m_asymmetric,
                    n_asymmetric: _n_asymmetric,
                    o_asymmetric: _o_asymmetric,
                    p_asymmetric: _p_asymmetric,
                    q_asymmetric: _q_asymmetric,
                    r_asymmetric: _r_asymmetric,
                    s_asymmetric: _s_asymmetric,
                    t_asymmetric: _t_asymmetric,
                    u_asymmetric: _u_asymmetric,
                    v_asymmetric: _v_asymmetric,
                    w_asymmetric: _w_asymmetric,
                    x_asymmetric: _x_asymmetric,
                    y_asymmetric: _y_asymmetric,
                    z_asymmetric: _z_asymmetric,
                    aa_asymmetric: _aa_asymmetric,
                    a_optional: _a_optional,
                    b_optional: _b_optional,
                    c_optional: _c_optional,
                    d_optional: _d_optional,
                    e_optional: _e_optional,
                    f_optional: _f_optional,
                    g_optional: _g_optional,
                    h_optional: _h_optional,
                    i_optional: _i_optional,
                    j_optional: _j_optional,
                    k_optional: _k_optional,
                    l_optional: _l_optional,
                    m_optional: _m_optional,
                    n_optional: _n_optional,
                    o_optional: _o_optional,
                    p_optional: _p_optional,
                    q_optional: _q_optional,
                    r_optional: _r_optional,
                    s_optional: _s_optional,
                    t_optional: _t_optional,
                    u_optional: _u_optional,
                    v_optional: _v_optional,
                    w_optional: _w_optional,
                    x_optional: _x_optional,
                    y_optional: _y_optional,
                    z_optional: _z_optional,
                    aa_optional: _aa_optional,
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &FooAtlas,
            ) -> ::std::io::Result<()> {
                {
                    let payload = &self.a_required;
                    let payload_atlas = &atlas.a_required;
                    super::super::serialize_field_header(writer, 0_u64, *payload_atlas, false)?;
                }

                {
                    let payload = &self.b_required;
                    let payload_atlas = &atlas.b_required;
                    super::super::serialize_field_header(writer, 1_u64, *payload_atlas, false)?;
                    if payload.to_bits() != 0_u64 {
                        writer.write_all(&payload.to_le_bytes())?;
                    }
                }

                {
                    let payload = &self.c_required;
                    let payload_atlas = &atlas.c_required;
                    super::super::serialize_field_header(writer, 2_u64, *payload_atlas, true)?;
                    {
                        let varint = *payload;
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                {
                    let payload = &self.d_required;
                    let payload_atlas = &atlas.d_required;
                    super::super::serialize_field_header(writer, 3_u64, *payload_atlas, true)?;
                    {
                        let varint = super::super::zigzag_encode(*payload);
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                {
                    let payload = &self.e_required;
                    let payload_atlas = &atlas.e_required;
                    super::super::serialize_field_header(writer, 4_u64, *payload_atlas, true)?;
                    {
                        let varint = *payload as u64;
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                {
                    let payload = &self.f_required;
                    let payload_atlas = &atlas.f_required;
                    super::super::serialize_field_header(writer, 5_u64, *payload_atlas, false)?;
                    writer.write_all(payload)?;
                }

                {
                    let payload = &self.g_required;
                    let payload_atlas = &atlas.g_required;
                    super::super::serialize_field_header(writer, 6_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.h_required;
                    let payload_atlas = &atlas.h_required;
                    super::super::serialize_field_header(writer, 7_u64, payload_atlas.size(), false)?;
                    payload.serialize_with_atlas(writer, payload_atlas)?;
                }

                {
                    let payload = &self.i_required;
                    let payload_atlas = &atlas.i_required;
                    super::super::serialize_field_header(writer, 8_u64, payload_atlas.size(), false)?;
                    payload.serialize_with_atlas(writer, payload_atlas)?;
                }

                {
                    let payload = &self.j_required;
                    let payload_atlas = &atlas.j_required;
                    super::super::serialize_field_header(writer, 9_u64, *payload_atlas, false)?;
                    {
                        let varint = payload.len() as u64 as u64;
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                {
                    let payload = &self.k_required;
                    let payload_atlas = &atlas.k_required;
                    super::super::serialize_field_header(writer, 10_u64, *payload_atlas, false)?;
                    for payload in payload {
                        writer.write_all(&payload.to_le_bytes())?;
                    }
                }

                {
                    let payload = &self.l_required;
                    let payload_atlas = &atlas.l_required;
                    super::super::serialize_field_header(writer, 11_u64, *payload_atlas, false)?;
                    for payload in payload {
                        {
                            let varint = *payload;
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                {
                    let payload = &self.m_required;
                    let payload_atlas = &atlas.m_required;
                    super::super::serialize_field_header(writer, 12_u64, *payload_atlas, false)?;
                    for payload in payload {
                        {
                            let varint = super::super::zigzag_encode(*payload);
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                {
                    let payload = &self.n_required;
                    let payload_atlas = &atlas.n_required;
                    super::super::serialize_field_header(writer, 13_u64, *payload_atlas, false)?;
                    for payload in payload {
                        {
                            let varint = *payload as u64;
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                {
                    let payload = &self.o_required;
                    let payload_atlas = &atlas.o_required;
                    super::super::serialize_field_header(writer, 14_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        writer.write_all(payload)?;
                    }
                }

                {
                    let payload = &self.p_required;
                    let payload_atlas = &atlas.p_required;
                    super::super::serialize_field_header(writer, 15_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        writer.write_all(payload.as_bytes())?;
                    }
                }

                {
                    let payload = &self.q_required;
                    let payload_atlas = &atlas.q_required;
                    super::super::serialize_field_header(writer, 16_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                    }
                }

                {
                    let payload = &self.r_required;
                    let payload_atlas = &atlas.r_required;
                    super::super::serialize_field_header(writer, 17_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                    }
                }

                {
                    let payload = &self.s_required;
                    let payload_atlas = &atlas.s_required;
                    super::super::serialize_field_header(writer, 18_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        {
                            let varint = payload.len() as u64 as u64;
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                {
                    let payload = &self.t_required;
                    let payload_atlas = &atlas.t_required;
                    super::super::serialize_field_header(writer, 19_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            writer.write_all(&payload.to_le_bytes())?;
                        }
                    }
                }

                {
                    let payload = &self.u_required;
                    let payload_atlas = &atlas.u_required;
                    super::super::serialize_field_header(writer, 20_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            {
                                let varint = *payload;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                    }
                }

                {
                    let payload = &self.v_required;
                    let payload_atlas = &atlas.v_required;
                    super::super::serialize_field_header(writer, 21_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            {
                                let varint = super::super::zigzag_encode(*payload);
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                    }
                }

                {
                    let payload = &self.w_required;
                    let payload_atlas = &atlas.w_required;
                    super::super::serialize_field_header(writer, 22_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            {
                                let varint = *payload as u64;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                    }
                }

                {
                    let payload = &self.x_required;
                    let payload_atlas = &atlas.x_required;
                    super::super::serialize_field_header(writer, 23_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload)?;
                        }
                    }
                }

                {
                    let payload = &self.y_required;
                    let payload_atlas = &atlas.y_required;
                    super::super::serialize_field_header(writer, 24_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload.as_bytes())?;
                        }
                    }
                }

                {
                    let payload = &self.z_required;
                    let payload_atlas = &atlas.z_required;
                    super::super::serialize_field_header(writer, 25_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                    }
                }

                {
                    let payload = &self.aa_required;
                    let payload_atlas = &atlas.aa_required;
                    super::super::serialize_field_header(writer, 26_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                    }
                }

                {
                    let payload = &self.a_asymmetric;
                    let payload_atlas = &atlas.a_asymmetric;
                    super::super::serialize_field_header(writer, 28_u64, *payload_atlas, false)?;
                }

                {
                    let payload = &self.b_asymmetric;
                    let payload_atlas = &atlas.b_asymmetric;
                    super::super::serialize_field_header(writer, 29_u64, *payload_atlas, false)?;
                    if payload.to_bits() != 0_u64 {
                        writer.write_all(&payload.to_le_bytes())?;
                    }
                }

                {
                    let payload = &self.c_asymmetric;
                    let payload_atlas = &atlas.c_asymmetric;
                    super::super::serialize_field_header(writer, 30_u64, *payload_atlas, true)?;
                    {
                        let varint = *payload;
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                {
                    let payload = &self.d_asymmetric;
                    let payload_atlas = &atlas.d_asymmetric;
                    super::super::serialize_field_header(writer, 31_u64, *payload_atlas, true)?;
                    {
                        let varint = super::super::zigzag_encode(*payload);
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                {
                    let payload = &self.e_asymmetric;
                    let payload_atlas = &atlas.e_asymmetric;
                    super::super::serialize_field_header(writer, 32_u64, *payload_atlas, true)?;
                    {
                        let varint = *payload as u64;
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                {
                    let payload = &self.f_asymmetric;
                    let payload_atlas = &atlas.f_asymmetric;
                    super::super::serialize_field_header(writer, 33_u64, *payload_atlas, false)?;
                    writer.write_all(payload)?;
                }

                {
                    let payload = &self.g_asymmetric;
                    let payload_atlas = &atlas.g_asymmetric;
                    super::super::serialize_field_header(writer, 34_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.h_asymmetric;
                    let payload_atlas = &atlas.h_asymmetric;
                    super::super::serialize_field_header(writer, 35_u64, payload_atlas.size(), false)?;
                    payload.serialize_with_atlas(writer, payload_atlas)?;
                }

                {
                    let payload = &self.i_asymmetric;
                    let payload_atlas = &atlas.i_asymmetric;
                    super::super::serialize_field_header(writer, 36_u64, payload_atlas.size(), false)?;
                    payload.serialize_with_atlas(writer, payload_atlas)?;
                }

                {
                    let payload = &self.j_asymmetric;
                    let payload_atlas = &atlas.j_asymmetric;
                    super::super::serialize_field_header(writer, 37_u64, *payload_atlas, false)?;
                    {
                        let varint = payload.len() as u64 as u64;
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                {
                    let payload = &self.k_asymmetric;
                    let payload_atlas = &atlas.k_asymmetric;
                    super::super::serialize_field_header(writer, 38_u64, *payload_atlas, false)?;
                    for payload in payload {
                        writer.write_all(&payload.to_le_bytes())?;
                    }
                }

                {
                    let payload = &self.l_asymmetric;
                    let payload_atlas = &atlas.l_asymmetric;
                    super::super::serialize_field_header(writer, 39_u64, *payload_atlas, false)?;
                    for payload in payload {
                        {
                            let varint = *payload;
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                {
                    let payload = &self.m_asymmetric;
                    let payload_atlas = &atlas.m_asymmetric;
                    super::super::serialize_field_header(writer, 40_u64, *payload_atlas, false)?;
                    for payload in payload {
                        {
                            let varint = super::super::zigzag_encode(*payload);
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                {
                    let payload = &self.n_asymmetric;
                    let payload_atlas = &atlas.n_asymmetric;
                    super::super::serialize_field_header(writer, 41_u64, *payload_atlas, false)?;
                    for payload in payload {
                        {
                            let varint = *payload as u64;
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                {
                    let payload = &self.o_asymmetric;
                    let payload_atlas = &atlas.o_asymmetric;
                    super::super::serialize_field_header(writer, 42_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        writer.write_all(payload)?;
                    }
                }

                {
                    let payload = &self.p_asymmetric;
                    let payload_atlas = &atlas.p_asymmetric;
                    super::super::serialize_field_header(writer, 43_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        writer.write_all(payload.as_bytes())?;
                    }
                }

                {
                    let payload = &self.q_asymmetric;
                    let payload_atlas = &atlas.q_asymmetric;
                    super::super::serialize_field_header(writer, 44_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                    }
                }

                {
                    let payload = &self.r_asymmetric;
                    let payload_atlas = &atlas.r_asymmetric;
                    super::super::serialize_field_header(writer, 45_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                    }
                }

                {
                    let payload = &self.s_asymmetric;
                    let payload_atlas = &atlas.s_asymmetric;
                    super::super::serialize_field_header(writer, 46_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        {
                            let varint = payload.len() as u64 as u64;
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                {
                    let payload = &self.t_asymmetric;
                    let payload_atlas = &atlas.t_asymmetric;
                    super::super::serialize_field_header(writer, 47_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            writer.write_all(&payload.to_le_bytes())?;
                        }
                    }
                }

                {
                    let payload = &self.u_asymmetric;
                    let payload_atlas = &atlas.u_asymmetric;
                    super::super::serialize_field_header(writer, 48_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            {
                                let varint = *payload;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                    }
                }

                {
                    let payload = &self.v_asymmetric;
                    let payload_atlas = &atlas.v_asymmetric;
                    super::super::serialize_field_header(writer, 49_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            {
                                let varint = super::super::zigzag_encode(*payload);
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                    }
                }

                {
                    let payload = &self.w_asymmetric;
                    let payload_atlas = &atlas.w_asymmetric;
                    super::super::serialize_field_header(writer, 50_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            {
                                let varint = *payload as u64;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                    }
                }

                {
                    let payload = &self.x_asymmetric;
                    let payload_atlas = &atlas.x_asymmetric;
                    super::super::serialize_field_header(writer, 51_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload)?;
                        }
                    }
                }

                {
                    let payload = &self.y_asymmetric;
                    let payload_atlas = &atlas.y_asymmetric;
                    super::super::serialize_field_header(writer, 52_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload.as_bytes())?;
                        }
                    }
                }

                {
                    let payload = &self.z_asymmetric;
                    let payload_atlas = &atlas.z_asymmetric;
                    super::super::serialize_field_header(writer, 53_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                    }
                }

                {
                    let payload = &self.aa_asymmetric;
                    let payload_atlas = &atlas.aa_asymmetric;
                    super::super::serialize_field_header(writer, 54_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.a_optional, &atlas.a_optional) {
                    super::super::serialize_field_header(writer, 56_u64, *payload_atlas, false)?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.b_optional, &atlas.b_optional) {
                    super::super::serialize_field_header(writer, 57_u64, *payload_atlas, false)?;
                    if payload.to_bits() != 0_u64 {
                        writer.write_all(&payload.to_le_bytes())?;
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.c_optional, &atlas.c_optional) {
                    super::super::serialize_field_header(writer, 58_u64, *payload_atlas, true)?;
                    {
                        let varint = *payload;
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.d_optional, &atlas.d_optional) {
                    super::super::serialize_field_header(writer, 59_u64, *payload_atlas, true)?;
                    {
                        let varint = super::super::zigzag_encode(*payload);
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.e_optional, &atlas.e_optional) {
                    super::super::serialize_field_header(writer, 60_u64, *payload_atlas, true)?;
                    {
                        let varint = *payload as u64;
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.f_optional, &atlas.f_optional) {
                    super::super::serialize_field_header(writer, 61_u64, *payload_atlas, false)?;
                    writer.write_all(payload)?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.g_optional, &atlas.g_optional) {
                    super::super::serialize_field_header(writer, 62_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.h_optional, &atlas.h_optional) {
                    super::super::serialize_field_header(writer, 63_u64, payload_atlas.size(), false)?;
                    payload.serialize_with_atlas(writer, payload_atlas)?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.i_optional, &atlas.i_optional) {
                    super::super::serialize_field_header(writer, 64_u64, payload_atlas.size(), false)?;
                    payload.serialize_with_atlas(writer, payload_atlas)?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.j_optional, &atlas.j_optional) {
                    super::super::serialize_field_header(writer, 65_u64, *payload_atlas, false)?;
                    {
                        let varint = payload.len() as u64 as u64;
                        match varint {
                            0_u64 => {}
                            1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                            567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.k_optional, &atlas.k_optional) {
                    super::super::serialize_field_header(writer, 66_u64, *payload_atlas, false)?;
                    for payload in payload {
                        writer.write_all(&payload.to_le_bytes())?;
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.l_optional, &atlas.l_optional) {
                    super::super::serialize_field_header(writer, 67_u64, *payload_atlas, false)?;
                    for payload in payload {
                        {
                            let varint = *payload;
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.m_optional, &atlas.m_optional) {
                    super::super::serialize_field_header(writer, 68_u64, *payload_atlas, false)?;
                    for payload in payload {
                        {
                            let varint = super::super::zigzag_encode(*payload);
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.n_optional, &atlas.n_optional) {
                    super::super::serialize_field_header(writer, 69_u64, *payload_atlas, false)?;
                    for payload in payload {
                        {
                            let varint = *payload as u64;
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.o_optional, &atlas.o_optional) {
                    super::super::serialize_field_header(writer, 70_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        writer.write_all(payload)?;
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.p_optional, &atlas.p_optional) {
                    super::super::serialize_field_header(writer, 71_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        writer.write_all(payload.as_bytes())?;
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.q_optional, &atlas.q_optional) {
                    super::super::serialize_field_header(writer, 72_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.r_optional, &atlas.r_optional) {
                    super::super::serialize_field_header(writer, 73_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.s_optional, &atlas.s_optional) {
                    super::super::serialize_field_header(writer, 74_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        {
                            let varint = payload.len() as u64 as u64;
                            super::super::serialize_varint(varint, writer)?;
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.t_optional, &atlas.t_optional) {
                    super::super::serialize_field_header(writer, 75_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            writer.write_all(&payload.to_le_bytes())?;
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.u_optional, &atlas.u_optional) {
                    super::super::serialize_field_header(writer, 76_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            {
                                let varint = *payload;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.v_optional, &atlas.v_optional) {
                    super::super::serialize_field_header(writer, 77_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            {
                                let varint = super::super::zigzag_encode(*payload);
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.w_optional, &atlas.w_optional) {
                    super::super::serialize_field_header(writer, 78_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(*payload_atlas as u64, writer)?;
                        for payload in payload {
                            {
                                let varint = *payload as u64;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.x_optional, &atlas.x_optional) {
                    super::super::serialize_field_header(writer, 79_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload)?;
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.y_optional, &atlas.y_optional) {
                    super::super::serialize_field_header(writer, 80_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload.as_bytes())?;
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.z_optional, &atlas.z_optional) {
                    super::super::serialize_field_header(writer, 81_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                    }
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.aa_optional, &atlas.aa_optional) {
                    super::super::serialize_field_header(writer, 82_u64, payload_atlas.0, false)?;
                    for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                        super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                    }
                }

                Ok(())
            }
        }

        impl FooAtlas {
            pub fn size(&self) -> usize {
                self._size
            }
        }

        #[derive(Clone, Debug)]
        pub enum BarAtlas {
            ARequired(usize, usize),
            BRequired(usize, usize),
            CRequired(usize, usize),
            DRequired(usize, usize),
            ERequired(usize, usize),
            FRequired(usize, usize),
            GRequired(usize, usize),
            HRequired(usize, LocalStructAtlas),
            IRequired(usize, super::super::degenerate::types::EmptyStructAtlas),
            JRequired(usize, usize),
            KRequired(usize, usize),
            LRequired(usize, usize),
            MRequired(usize, usize),
            NRequired(usize, usize),
            ORequired(usize, (usize, Vec<usize>)),
            PRequired(usize, (usize, Vec<usize>)),
            QRequired(usize, (usize, Vec<LocalStructAtlas>)),
            RRequired(usize, (usize, Vec<super::super::degenerate::types::EmptyStructAtlas>)),
            SRequired(usize, (usize, Vec<usize>)),
            TRequired(usize, (usize, Vec<usize>)),
            URequired(usize, (usize, Vec<usize>)),
            VRequired(usize, (usize, Vec<usize>)),
            WRequired(usize, (usize, Vec<usize>)),
            XRequired(usize, (usize, Vec<(usize, Vec<usize>)>)),
            YRequired(usize, (usize, Vec<(usize, Vec<usize>)>)),
            ZRequired(usize, (usize, Vec<(usize, Vec<LocalStructAtlas>)>)),
            AaRequired(usize, (usize, Vec<(usize, Vec<super::super::degenerate::types::EmptyStructAtlas>)>)),
            AAsymmetric(usize, usize, Box<BarAtlas>),
            BAsymmetric(usize, usize, Box<BarAtlas>),
            CAsymmetric(usize, usize, Box<BarAtlas>),
            DAsymmetric(usize, usize, Box<BarAtlas>),
            EAsymmetric(usize, usize, Box<BarAtlas>),
            FAsymmetric(usize, usize, Box<BarAtlas>),
            GAsymmetric(usize, usize, Box<BarAtlas>),
            HAsymmetric(usize, LocalStructAtlas, Box<BarAtlas>),
            IAsymmetric(usize, super::super::degenerate::types::EmptyStructAtlas, Box<BarAtlas>),
            JAsymmetric(usize, usize, Box<BarAtlas>),
            KAsymmetric(usize, usize, Box<BarAtlas>),
            LAsymmetric(usize, usize, Box<BarAtlas>),
            MAsymmetric(usize, usize, Box<BarAtlas>),
            NAsymmetric(usize, usize, Box<BarAtlas>),
            OAsymmetric(usize, (usize, Vec<usize>), Box<BarAtlas>),
            PAsymmetric(usize, (usize, Vec<usize>), Box<BarAtlas>),
            QAsymmetric(usize, (usize, Vec<LocalStructAtlas>), Box<BarAtlas>),
            RAsymmetric(usize, (usize, Vec<super::super::degenerate::types::EmptyStructAtlas>), Box<BarAtlas>),
            SAsymmetric(usize, (usize, Vec<usize>), Box<BarAtlas>),
            TAsymmetric(usize, (usize, Vec<usize>), Box<BarAtlas>),
            UAsymmetric(usize, (usize, Vec<usize>), Box<BarAtlas>),
            VAsymmetric(usize, (usize, Vec<usize>), Box<BarAtlas>),
            WAsymmetric(usize, (usize, Vec<usize>), Box<BarAtlas>),
            XAsymmetric(usize, (usize, Vec<(usize, Vec<usize>)>), Box<BarAtlas>),
            YAsymmetric(usize, (usize, Vec<(usize, Vec<usize>)>), Box<BarAtlas>),
            ZAsymmetric(usize, (usize, Vec<(usize, Vec<LocalStructAtlas>)>), Box<BarAtlas>),
            AaAsymmetric(usize, (usize, Vec<(usize, Vec<super::super::degenerate::types::EmptyStructAtlas>)>), Box<BarAtlas>),
            AOptional(usize, usize, Box<BarAtlas>),
            BOptional(usize, usize, Box<BarAtlas>),
            COptional(usize, usize, Box<BarAtlas>),
            DOptional(usize, usize, Box<BarAtlas>),
            EOptional(usize, usize, Box<BarAtlas>),
            FOptional(usize, usize, Box<BarAtlas>),
            GOptional(usize, usize, Box<BarAtlas>),
            HOptional(usize, LocalStructAtlas, Box<BarAtlas>),
            IOptional(usize, super::super::degenerate::types::EmptyStructAtlas, Box<BarAtlas>),
            JOptional(usize, usize, Box<BarAtlas>),
            KOptional(usize, usize, Box<BarAtlas>),
            LOptional(usize, usize, Box<BarAtlas>),
            MOptional(usize, usize, Box<BarAtlas>),
            NOptional(usize, usize, Box<BarAtlas>),
            OOptional(usize, (usize, Vec<usize>), Box<BarAtlas>),
            POptional(usize, (usize, Vec<usize>), Box<BarAtlas>),
            QOptional(usize, (usize, Vec<LocalStructAtlas>), Box<BarAtlas>),
            ROptional(usize, (usize, Vec<super::super::degenerate::types::EmptyStructAtlas>), Box<BarAtlas>),
            SOptional(usize, (usize, Vec<usize>), Box<BarAtlas>),
            TOptional(usize, (usize, Vec<usize>), Box<BarAtlas>),
            UOptional(usize, (usize, Vec<usize>), Box<BarAtlas>),
            VOptional(usize, (usize, Vec<usize>), Box<BarAtlas>),
            WOptional(usize, (usize, Vec<usize>), Box<BarAtlas>),
            XOptional(usize, (usize, Vec<(usize, Vec<usize>)>), Box<BarAtlas>),
            YOptional(usize, (usize, Vec<(usize, Vec<usize>)>), Box<BarAtlas>),
            ZOptional(usize, (usize, Vec<(usize, Vec<LocalStructAtlas>)>), Box<BarAtlas>),
            AaOptional(usize, (usize, Vec<(usize, Vec<super::super::degenerate::types::EmptyStructAtlas>)>), Box<BarAtlas>),
        }

        #[derive(Clone, Debug)]
        pub enum BarOut {
            ARequired,
            BRequired(f64),
            CRequired(u64),
            DRequired(i64),
            ERequired(bool),
            FRequired(Vec<u8>),
            GRequired(String),
            HRequired(LocalStructOut),
            IRequired(super::super::degenerate::types::EmptyStructOut),
            JRequired(Vec<()>),
            KRequired(Vec<f64>),
            LRequired(Vec<u64>),
            MRequired(Vec<i64>),
            NRequired(Vec<bool>),
            ORequired(Vec<Vec<u8>>),
            PRequired(Vec<String>),
            QRequired(Vec<LocalStructOut>),
            RRequired(Vec<super::super::degenerate::types::EmptyStructOut>),
            SRequired(Vec<Vec<()>>),
            TRequired(Vec<Vec<f64>>),
            URequired(Vec<Vec<u64>>),
            VRequired(Vec<Vec<i64>>),
            WRequired(Vec<Vec<bool>>),
            XRequired(Vec<Vec<Vec<u8>>>),
            YRequired(Vec<Vec<String>>),
            ZRequired(Vec<Vec<LocalStructOut>>),
            AaRequired(Vec<Vec<super::super::degenerate::types::EmptyStructOut>>),
            AAsymmetric(Box<BarOut>),
            BAsymmetric(f64, Box<BarOut>),
            CAsymmetric(u64, Box<BarOut>),
            DAsymmetric(i64, Box<BarOut>),
            EAsymmetric(bool, Box<BarOut>),
            FAsymmetric(Vec<u8>, Box<BarOut>),
            GAsymmetric(String, Box<BarOut>),
            HAsymmetric(LocalStructOut, Box<BarOut>),
            IAsymmetric(super::super::degenerate::types::EmptyStructOut, Box<BarOut>),
            JAsymmetric(Vec<()>, Box<BarOut>),
            KAsymmetric(Vec<f64>, Box<BarOut>),
            LAsymmetric(Vec<u64>, Box<BarOut>),
            MAsymmetric(Vec<i64>, Box<BarOut>),
            NAsymmetric(Vec<bool>, Box<BarOut>),
            OAsymmetric(Vec<Vec<u8>>, Box<BarOut>),
            PAsymmetric(Vec<String>, Box<BarOut>),
            QAsymmetric(Vec<LocalStructOut>, Box<BarOut>),
            RAsymmetric(Vec<super::super::degenerate::types::EmptyStructOut>, Box<BarOut>),
            SAsymmetric(Vec<Vec<()>>, Box<BarOut>),
            TAsymmetric(Vec<Vec<f64>>, Box<BarOut>),
            UAsymmetric(Vec<Vec<u64>>, Box<BarOut>),
            VAsymmetric(Vec<Vec<i64>>, Box<BarOut>),
            WAsymmetric(Vec<Vec<bool>>, Box<BarOut>),
            XAsymmetric(Vec<Vec<Vec<u8>>>, Box<BarOut>),
            YAsymmetric(Vec<Vec<String>>, Box<BarOut>),
            ZAsymmetric(Vec<Vec<LocalStructOut>>, Box<BarOut>),
            AaAsymmetric(Vec<Vec<super::super::degenerate::types::EmptyStructOut>>, Box<BarOut>),
            AOptional(Box<BarOut>),
            BOptional(f64, Box<BarOut>),
            COptional(u64, Box<BarOut>),
            DOptional(i64, Box<BarOut>),
            EOptional(bool, Box<BarOut>),
            FOptional(Vec<u8>, Box<BarOut>),
            GOptional(String, Box<BarOut>),
            HOptional(LocalStructOut, Box<BarOut>),
            IOptional(super::super::degenerate::types::EmptyStructOut, Box<BarOut>),
            JOptional(Vec<()>, Box<BarOut>),
            KOptional(Vec<f64>, Box<BarOut>),
            LOptional(Vec<u64>, Box<BarOut>),
            MOptional(Vec<i64>, Box<BarOut>),
            NOptional(Vec<bool>, Box<BarOut>),
            OOptional(Vec<Vec<u8>>, Box<BarOut>),
            POptional(Vec<String>, Box<BarOut>),
            QOptional(Vec<LocalStructOut>, Box<BarOut>),
            ROptional(Vec<super::super::degenerate::types::EmptyStructOut>, Box<BarOut>),
            SOptional(Vec<Vec<()>>, Box<BarOut>),
            TOptional(Vec<Vec<f64>>, Box<BarOut>),
            UOptional(Vec<Vec<u64>>, Box<BarOut>),
            VOptional(Vec<Vec<i64>>, Box<BarOut>),
            WOptional(Vec<Vec<bool>>, Box<BarOut>),
            XOptional(Vec<Vec<Vec<u8>>>, Box<BarOut>),
            YOptional(Vec<Vec<String>>, Box<BarOut>),
            ZOptional(Vec<Vec<LocalStructOut>>, Box<BarOut>),
            AaOptional(Vec<Vec<super::super::degenerate::types::EmptyStructOut>>, Box<BarOut>),
        }

        #[derive(Clone, Debug)]
        pub enum BarIn {
            ARequired,
            BRequired(f64),
            CRequired(u64),
            DRequired(i64),
            ERequired(bool),
            FRequired(Vec<u8>),
            GRequired(String),
            HRequired(LocalStructIn),
            IRequired(super::super::degenerate::types::EmptyStructIn),
            JRequired(Vec<()>),
            KRequired(Vec<f64>),
            LRequired(Vec<u64>),
            MRequired(Vec<i64>),
            NRequired(Vec<bool>),
            ORequired(Vec<Vec<u8>>),
            PRequired(Vec<String>),
            QRequired(Vec<LocalStructIn>),
            RRequired(Vec<super::super::degenerate::types::EmptyStructIn>),
            SRequired(Vec<Vec<()>>),
            TRequired(Vec<Vec<f64>>),
            URequired(Vec<Vec<u64>>),
            VRequired(Vec<Vec<i64>>),
            WRequired(Vec<Vec<bool>>),
            XRequired(Vec<Vec<Vec<u8>>>),
            YRequired(Vec<Vec<String>>),
            ZRequired(Vec<Vec<LocalStructIn>>),
            AaRequired(Vec<Vec<super::super::degenerate::types::EmptyStructIn>>),
            AAsymmetric,
            BAsymmetric(f64),
            CAsymmetric(u64),
            DAsymmetric(i64),
            EAsymmetric(bool),
            FAsymmetric(Vec<u8>),
            GAsymmetric(String),
            HAsymmetric(LocalStructIn),
            IAsymmetric(super::super::degenerate::types::EmptyStructIn),
            JAsymmetric(Vec<()>),
            KAsymmetric(Vec<f64>),
            LAsymmetric(Vec<u64>),
            MAsymmetric(Vec<i64>),
            NAsymmetric(Vec<bool>),
            OAsymmetric(Vec<Vec<u8>>),
            PAsymmetric(Vec<String>),
            QAsymmetric(Vec<LocalStructIn>),
            RAsymmetric(Vec<super::super::degenerate::types::EmptyStructIn>),
            SAsymmetric(Vec<Vec<()>>),
            TAsymmetric(Vec<Vec<f64>>),
            UAsymmetric(Vec<Vec<u64>>),
            VAsymmetric(Vec<Vec<i64>>),
            WAsymmetric(Vec<Vec<bool>>),
            XAsymmetric(Vec<Vec<Vec<u8>>>),
            YAsymmetric(Vec<Vec<String>>),
            ZAsymmetric(Vec<Vec<LocalStructIn>>),
            AaAsymmetric(Vec<Vec<super::super::degenerate::types::EmptyStructIn>>),
            AOptional(Box<BarIn>),
            BOptional(f64, Box<BarIn>),
            COptional(u64, Box<BarIn>),
            DOptional(i64, Box<BarIn>),
            EOptional(bool, Box<BarIn>),
            FOptional(Vec<u8>, Box<BarIn>),
            GOptional(String, Box<BarIn>),
            HOptional(LocalStructIn, Box<BarIn>),
            IOptional(super::super::degenerate::types::EmptyStructIn, Box<BarIn>),
            JOptional(Vec<()>, Box<BarIn>),
            KOptional(Vec<f64>, Box<BarIn>),
            LOptional(Vec<u64>, Box<BarIn>),
            MOptional(Vec<i64>, Box<BarIn>),
            NOptional(Vec<bool>, Box<BarIn>),
            OOptional(Vec<Vec<u8>>, Box<BarIn>),
            POptional(Vec<String>, Box<BarIn>),
            QOptional(Vec<LocalStructIn>, Box<BarIn>),
            ROptional(Vec<super::super::degenerate::types::EmptyStructIn>, Box<BarIn>),
            SOptional(Vec<Vec<()>>, Box<BarIn>),
            TOptional(Vec<Vec<f64>>, Box<BarIn>),
            UOptional(Vec<Vec<u64>>, Box<BarIn>),
            VOptional(Vec<Vec<i64>>, Box<BarIn>),
            WOptional(Vec<Vec<bool>>, Box<BarIn>),
            XOptional(Vec<Vec<Vec<u8>>>, Box<BarIn>),
            YOptional(Vec<Vec<String>>, Box<BarIn>),
            ZOptional(Vec<Vec<LocalStructIn>>, Box<BarIn>),
            AaOptional(Vec<Vec<super::super::degenerate::types::EmptyStructIn>>, Box<BarIn>),
        }

        impl super::super::Serialize for BarOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for BarIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                loop {
                    let (index, payload_size) = super::super::deserialize_field_header(&mut *reader)?;

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        0 => {
                            let payload = ();
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::ARequired);
                        }
                        1 => {
                            let payload = if payload_size == 0_usize {
                                0.0_f64
                            } else {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                f64::from_le_bytes(buffer)
                            };
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::BRequired(payload));
                        }
                        2 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::CRequired(payload));
                        }
                        3 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = super::super::zigzag_decode(payload);
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::DRequired(payload));
                        }
                        4 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = payload != 0_u64;
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::ERequired(payload));
                        }
                        5 => {
                            let mut payload = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::FRequired(payload));
                        }
                        6 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::GRequired(payload));
                        }
                        7 => {
                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::HRequired(payload));
                        }
                        8 => {
                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::IRequired(payload));
                        }
                        9 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = vec![(); payload as usize];
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::JRequired(payload));
                        }
                        10 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                let payload = f64::from_le_bytes(buffer);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::KRequired(payload));
                        }
                        11 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::LRequired(payload));
                        }
                        12 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = super::super::zigzag_decode(payload);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::MRequired(payload));
                        }
                        13 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = payload != 0_u64;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::NRequired(payload));
                        }
                        14 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::ORequired(payload));
                        }
                        15 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut buffer = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                    let payload = std::str::from_utf8(&buffer).map_or_else(
                                        |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                        |result| Ok(result.to_owned()),
                                    )?;
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::PRequired(payload));
                        }
                        16 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::QRequired(payload));
                        }
                        17 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::RRequired(payload));
                        }
                        18 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                    let payload = vec![(); payload as usize];
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::SRequired(payload));
                        }
                        19 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                        let mut buffer = [0; 8];
                                        ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                        let payload = f64::from_le_bytes(buffer);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::TRequired(payload));
                        }
                        20 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::URequired(payload));
                        }
                        21 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = super::super::zigzag_decode(payload);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::VRequired(payload));
                        }
                        22 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = payload != 0_u64;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::WRequired(payload));
                        }
                        23 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut payload = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::XRequired(payload));
                        }
                        24 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut buffer = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                                |result| Ok(result.to_owned()),
                                            )?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::YRequired(payload));
                        }
                        25 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::ZRequired(payload));
                        }
                        26 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::AaRequired(payload));
                        }
                        28 => {
                            let payload = ();
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::AAsymmetric);
                        }
                        29 => {
                            let payload = if payload_size == 0_usize {
                                0.0_f64
                            } else {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                f64::from_le_bytes(buffer)
                            };
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::BAsymmetric(payload));
                        }
                        30 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::CAsymmetric(payload));
                        }
                        31 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = super::super::zigzag_decode(payload);
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::DAsymmetric(payload));
                        }
                        32 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = payload != 0_u64;
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::EAsymmetric(payload));
                        }
                        33 => {
                            let mut payload = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::FAsymmetric(payload));
                        }
                        34 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::GAsymmetric(payload));
                        }
                        35 => {
                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::HAsymmetric(payload));
                        }
                        36 => {
                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::IAsymmetric(payload));
                        }
                        37 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = vec![(); payload as usize];
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::JAsymmetric(payload));
                        }
                        38 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                let payload = f64::from_le_bytes(buffer);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::KAsymmetric(payload));
                        }
                        39 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::LAsymmetric(payload));
                        }
                        40 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = super::super::zigzag_decode(payload);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::MAsymmetric(payload));
                        }
                        41 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = payload != 0_u64;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::NAsymmetric(payload));
                        }
                        42 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::OAsymmetric(payload));
                        }
                        43 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut buffer = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                    let payload = std::str::from_utf8(&buffer).map_or_else(
                                        |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                        |result| Ok(result.to_owned()),
                                    )?;
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::PAsymmetric(payload));
                        }
                        44 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::QAsymmetric(payload));
                        }
                        45 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::RAsymmetric(payload));
                        }
                        46 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                    let payload = vec![(); payload as usize];
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::SAsymmetric(payload));
                        }
                        47 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                        let mut buffer = [0; 8];
                                        ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                        let payload = f64::from_le_bytes(buffer);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::TAsymmetric(payload));
                        }
                        48 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::UAsymmetric(payload));
                        }
                        49 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = super::super::zigzag_decode(payload);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::VAsymmetric(payload));
                        }
                        50 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = payload != 0_u64;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::WAsymmetric(payload));
                        }
                        51 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut payload = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::XAsymmetric(payload));
                        }
                        52 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut buffer = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                                |result| Ok(result.to_owned()),
                                            )?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::YAsymmetric(payload));
                        }
                        53 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::ZAsymmetric(payload));
                        }
                        54 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            super::super::finish(&mut *reader)?;
                            return Ok(BarIn::AaAsymmetric(payload));
                        }
                        56 => {
                            let payload = ();
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::AOptional(fallback));
                        }
                        57 => {
                            let payload = if payload_size == 0_usize {
                                0.0_f64
                            } else {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                f64::from_le_bytes(buffer)
                            };
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::BOptional(payload, fallback));
                        }
                        58 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::COptional(payload, fallback));
                        }
                        59 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = super::super::zigzag_decode(payload);
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::DOptional(payload, fallback));
                        }
                        60 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = payload != 0_u64;
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::EOptional(payload, fallback));
                        }
                        61 => {
                            let mut payload = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::FOptional(payload, fallback));
                        }
                        62 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::GOptional(payload, fallback));
                        }
                        63 => {
                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::HOptional(payload, fallback));
                        }
                        64 => {
                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::IOptional(payload, fallback));
                        }
                        65 => {
                            let payload = match payload_size {
                                0_usize => 0_u64,
                                8_usize => {
                                    let mut buffer = [0; 8];
                                    ::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;
                                    u64::from_le_bytes(buffer)
                                }
                                _ => super::super::deserialize_varint(&mut sub_reader)?,
                            };
                            let payload = vec![(); payload as usize];
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::JOptional(payload, fallback));
                        }
                        66 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                let mut buffer = [0; 8];
                                ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                let payload = f64::from_le_bytes(buffer);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::KOptional(payload, fallback));
                        }
                        67 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::LOptional(payload, fallback));
                        }
                        68 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = super::super::zigzag_decode(payload);
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::MOptional(payload, fallback));
                        }
                        69 => {
                            fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                let payload = payload != 0_u64;
                                Ok(payload)
                            }
                            let mut payload = Vec::new();
                            loop {
                                payload.push(match deserialize_element(&mut sub_reader) {
                                    Ok(element) => element,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::NOptional(payload, fallback));
                        }
                        70 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::OOptional(payload, fallback));
                        }
                        71 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut buffer = vec![];
                                    ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                    let payload = std::str::from_utf8(&buffer).map_or_else(
                                        |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                        |result| Ok(result.to_owned()),
                                    )?;
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::POptional(payload, fallback));
                        }
                        72 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::QOptional(payload, fallback));
                        }
                        73 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::ROptional(payload, fallback));
                        }
                        74 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                    let payload = vec![(); payload as usize];
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::SOptional(payload, fallback));
                        }
                        75 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<f64> {
                                        let mut buffer = [0; 8];
                                        ::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;
                                        let payload = f64::from_le_bytes(buffer);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::TOptional(payload, fallback));
                        }
                        76 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<u64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::UOptional(payload, fallback));
                        }
                        77 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<i64> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = super::super::zigzag_decode(payload);
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::VOptional(payload, fallback));
                        }
                        78 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> ::std::io::Result<bool> {
                                        let payload = super::super::deserialize_varint(&mut sub_reader)?;
                                        let payload = payload != 0_u64;
                                        Ok(payload)
                                    }
                                    let mut payload = Vec::new();
                                    loop {
                                        payload.push(match deserialize_element(&mut sub_reader) {
                                            Ok(element) => element,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        });
                                    }
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::WOptional(payload, fallback));
                        }
                        79 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut payload = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::XOptional(payload, fallback));
                        }
                        80 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let mut buffer = vec![];
                                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                                |result| Ok(result.to_owned()),
                                            )?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::YOptional(payload, fallback));
                        }
                        81 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <LocalStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::ZOptional(payload, fallback));
                        }
                        82 => {
                            let mut payload = Vec::new();
                            loop {
                                let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                    Ok(element_size) => element_size,
                                    Err(err) => {
                                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                            break;
                                        }
                                        return Err(err);
                                    }
                                };
                                let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                payload.push({
                                    let mut payload = Vec::new();
                                    loop {
                                        let element_size = match super::super::deserialize_varint(&mut sub_reader) {
                                            Ok(element_size) => element_size,
                                            Err(err) => {
                                                if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                                    break;
                                                }
                                                return Err(err);
                                            }
                                        };
                                        let mut sub_reader = ::std::io::Read::take(&mut sub_reader, element_size as u64);
                                        payload.push({
                                            let payload = <super::super::degenerate::types::EmptyStructIn as super::super::Deserialize>::deserialize(&mut sub_reader)?;
                                            payload
                                        });
                                    }
                                    payload
                                });
                            }
                            let fallback = Box::new(<BarIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(BarIn::AaOptional(payload, fallback));
                        }
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }
            }
        }

        impl From<BarOut> for BarIn {
            fn from(message: BarOut) -> Self {
                match message {
                    BarOut::ARequired => BarIn::ARequired,
                    BarOut::BRequired(payload) => BarIn::BRequired(payload.into()),
                    BarOut::CRequired(payload) => BarIn::CRequired(payload.into()),
                    BarOut::DRequired(payload) => BarIn::DRequired(payload.into()),
                    BarOut::ERequired(payload) => BarIn::ERequired(payload.into()),
                    BarOut::FRequired(payload) => BarIn::FRequired(payload.into()),
                    BarOut::GRequired(payload) => BarIn::GRequired(payload.into()),
                    BarOut::HRequired(payload) => BarIn::HRequired(payload.into()),
                    BarOut::IRequired(payload) => BarIn::IRequired(payload.into()),
                    BarOut::JRequired(payload) => BarIn::JRequired(payload.into()),
                    BarOut::KRequired(payload) => BarIn::KRequired(payload.into()),
                    BarOut::LRequired(payload) => BarIn::LRequired(payload.into()),
                    BarOut::MRequired(payload) => BarIn::MRequired(payload.into()),
                    BarOut::NRequired(payload) => BarIn::NRequired(payload.into()),
                    BarOut::ORequired(payload) => BarIn::ORequired(payload.into()),
                    BarOut::PRequired(payload) => BarIn::PRequired(payload.into()),
                    BarOut::QRequired(payload) => BarIn::QRequired(payload.into_iter().map(|x| x.into()).collect::<Vec<_>>()),
                    BarOut::RRequired(payload) => BarIn::RRequired(payload.into_iter().map(|x| x.into()).collect::<Vec<_>>()),
                    BarOut::SRequired(payload) => BarIn::SRequired(payload.into()),
                    BarOut::TRequired(payload) => BarIn::TRequired(payload.into()),
                    BarOut::URequired(payload) => BarIn::URequired(payload.into()),
                    BarOut::VRequired(payload) => BarIn::VRequired(payload.into()),
                    BarOut::WRequired(payload) => BarIn::WRequired(payload.into()),
                    BarOut::XRequired(payload) => BarIn::XRequired(payload.into()),
                    BarOut::YRequired(payload) => BarIn::YRequired(payload.into()),
                    BarOut::ZRequired(payload) => BarIn::ZRequired(payload.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>()),
                    BarOut::AaRequired(payload) => BarIn::AaRequired(payload.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>()),
                    BarOut::AAsymmetric(fallback) => BarIn::AAsymmetric,
                    BarOut::BAsymmetric(payload, fallback) => BarIn::BAsymmetric(payload.into()),
                    BarOut::CAsymmetric(payload, fallback) => BarIn::CAsymmetric(payload.into()),
                    BarOut::DAsymmetric(payload, fallback) => BarIn::DAsymmetric(payload.into()),
                    BarOut::EAsymmetric(payload, fallback) => BarIn::EAsymmetric(payload.into()),
                    BarOut::FAsymmetric(payload, fallback) => BarIn::FAsymmetric(payload.into()),
                    BarOut::GAsymmetric(payload, fallback) => BarIn::GAsymmetric(payload.into()),
                    BarOut::HAsymmetric(payload, fallback) => BarIn::HAsymmetric(payload.into()),
                    BarOut::IAsymmetric(payload, fallback) => BarIn::IAsymmetric(payload.into()),
                    BarOut::JAsymmetric(payload, fallback) => BarIn::JAsymmetric(payload.into()),
                    BarOut::KAsymmetric(payload, fallback) => BarIn::KAsymmetric(payload.into()),
                    BarOut::LAsymmetric(payload, fallback) => BarIn::LAsymmetric(payload.into()),
                    BarOut::MAsymmetric(payload, fallback) => BarIn::MAsymmetric(payload.into()),
                    BarOut::NAsymmetric(payload, fallback) => BarIn::NAsymmetric(payload.into()),
                    BarOut::OAsymmetric(payload, fallback) => BarIn::OAsymmetric(payload.into()),
                    BarOut::PAsymmetric(payload, fallback) => BarIn::PAsymmetric(payload.into()),
                    BarOut::QAsymmetric(payload, fallback) => BarIn::QAsymmetric(payload.into_iter().map(|x| x.into()).collect::<Vec<_>>()),
                    BarOut::RAsymmetric(payload, fallback) => BarIn::RAsymmetric(payload.into_iter().map(|x| x.into()).collect::<Vec<_>>()),
                    BarOut::SAsymmetric(payload, fallback) => BarIn::SAsymmetric(payload.into()),
                    BarOut::TAsymmetric(payload, fallback) => BarIn::TAsymmetric(payload.into()),
                    BarOut::UAsymmetric(payload, fallback) => BarIn::UAsymmetric(payload.into()),
                    BarOut::VAsymmetric(payload, fallback) => BarIn::VAsymmetric(payload.into()),
                    BarOut::WAsymmetric(payload, fallback) => BarIn::WAsymmetric(payload.into()),
                    BarOut::XAsymmetric(payload, fallback) => BarIn::XAsymmetric(payload.into()),
                    BarOut::YAsymmetric(payload, fallback) => BarIn::YAsymmetric(payload.into()),
                    BarOut::ZAsymmetric(payload, fallback) => BarIn::ZAsymmetric(payload.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>()),
                    BarOut::AaAsymmetric(payload, fallback) => BarIn::AaAsymmetric(payload.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>()),
                    BarOut::AOptional(fallback) => BarIn::AOptional(Box::new((*fallback).into())),
                    BarOut::BOptional(payload, fallback) => BarIn::BOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::COptional(payload, fallback) => BarIn::COptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::DOptional(payload, fallback) => BarIn::DOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::EOptional(payload, fallback) => BarIn::EOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::FOptional(payload, fallback) => BarIn::FOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::GOptional(payload, fallback) => BarIn::GOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::HOptional(payload, fallback) => BarIn::HOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::IOptional(payload, fallback) => BarIn::IOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::JOptional(payload, fallback) => BarIn::JOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::KOptional(payload, fallback) => BarIn::KOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::LOptional(payload, fallback) => BarIn::LOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::MOptional(payload, fallback) => BarIn::MOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::NOptional(payload, fallback) => BarIn::NOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::OOptional(payload, fallback) => BarIn::OOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::POptional(payload, fallback) => BarIn::POptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::QOptional(payload, fallback) => BarIn::QOptional(payload.into_iter().map(|x| x.into()).collect::<Vec<_>>(), Box::new((*fallback).into())),
                    BarOut::ROptional(payload, fallback) => BarIn::ROptional(payload.into_iter().map(|x| x.into()).collect::<Vec<_>>(), Box::new((*fallback).into())),
                    BarOut::SOptional(payload, fallback) => BarIn::SOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::TOptional(payload, fallback) => BarIn::TOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::UOptional(payload, fallback) => BarIn::UOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::VOptional(payload, fallback) => BarIn::VOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::WOptional(payload, fallback) => BarIn::WOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::XOptional(payload, fallback) => BarIn::XOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::YOptional(payload, fallback) => BarIn::YOptional(payload.into(), Box::new((*fallback).into())),
                    BarOut::ZOptional(payload, fallback) => BarIn::ZOptional(payload.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>(), Box::new((*fallback).into())),
                    BarOut::AaOptional(payload, fallback) => BarIn::AaOptional(payload.into_iter().map(|x| x.into_iter().map(|x| x.into()).collect::<Vec<_>>()).collect::<Vec<_>>(), Box::new((*fallback).into())),
                }
            }
        }

        impl BarOut {
            pub fn atlas(&self) -> BarAtlas {
                match *self {
                    BarOut::ARequired => {
                        let payload = &();
                        let payload_atlas = (0_usize);
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::ARequired(super::super::field_header_size(0_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::BRequired(ref payload) => {
                        let payload_atlas = (if payload.to_bits() == 0_u64 { 0_usize } else { 8_usize });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::BRequired(super::super::field_header_size(1_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::CRequired(ref payload) => {
                        let payload_atlas = (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::CRequired(super::super::field_header_size(2_u64, payload_size, true) + payload_size, payload_atlas)
                    }
                    BarOut::DRequired(ref payload) => {
                        let payload_atlas = ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::DRequired(super::super::field_header_size(3_u64, payload_size, true) + payload_size, payload_atlas)
                    }
                    BarOut::ERequired(ref payload) => {
                        let payload_atlas = (if *payload { 1_usize } else { 0_usize });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::ERequired(super::super::field_header_size(4_u64, payload_size, true) + payload_size, payload_atlas)
                    }
                    BarOut::FRequired(ref payload) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::FRequired(super::super::field_header_size(5_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::GRequired(ref payload) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::GRequired(super::super::field_header_size(6_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::HRequired(ref payload) => {
                        let payload_atlas = (payload.atlas());
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.size() };
                        BarAtlas::HRequired(super::super::field_header_size(7_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::IRequired(ref payload) => {
                        let payload_atlas = (payload.atlas());
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.size() };
                        BarAtlas::IRequired(super::super::field_header_size(8_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::JRequired(ref payload) => {
                        let payload_atlas = ({ let payload = &(payload.len() as u64); (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::JRequired(super::super::field_header_size(9_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::KRequired(ref payload) => {
                        let payload_atlas = (8_usize * payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::KRequired(super::super::field_header_size(10_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::LRequired(ref payload) => {
                        let payload_atlas = (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload))));
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::LRequired(super::super::field_header_size(11_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::MRequired(ref payload) => {
                        let payload_atlas = (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) })));
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::MRequired(super::super::field_header_size(12_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::NRequired(ref payload) => {
                        let payload_atlas = (payload.iter().fold(0_usize, |x, payload| x + (1_usize)));
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        BarAtlas::NRequired(super::super::field_header_size(13_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::ORequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::ORequired(super::super::field_header_size(14_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::PRequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::PRequired(super::super::field_header_size(15_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::QRequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::QRequired(super::super::field_header_size(16_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::RRequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::RRequired(super::super::field_header_size(17_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::SRequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let payload = &(payload.len() as u64); (super::super::varint_size_from_value(*payload)) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::SRequired(super::super::field_header_size(18_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::TRequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (8_usize * payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::TRequired(super::super::field_header_size(19_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::URequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload))))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::URequired(super::super::field_header_size(20_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::VRequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) })))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::VRequired(super::super::field_header_size(21_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::WRequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (1_usize)))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::WRequired(super::super::field_header_size(22_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::XRequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::XRequired(super::super::field_header_size(23_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::YRequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::YRequired(super::super::field_header_size(24_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::ZRequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::ZRequired(super::super::field_header_size(25_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::AaRequired(ref payload) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        BarAtlas::AaRequired(super::super::field_header_size(26_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    BarOut::AAsymmetric(ref fallback) => {
                        let payload = &();
                        let payload_atlas = (0_usize);
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::AAsymmetric(super::super::field_header_size(28_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::BAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (if payload.to_bits() == 0_u64 { 0_usize } else { 8_usize });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::BAsymmetric(super::super::field_header_size(29_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::CAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::CAsymmetric(super::super::field_header_size(30_u64, payload_size, true) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::DAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::DAsymmetric(super::super::field_header_size(31_u64, payload_size, true) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::EAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (if *payload { 1_usize } else { 0_usize });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::EAsymmetric(super::super::field_header_size(32_u64, payload_size, true) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::FAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::FAsymmetric(super::super::field_header_size(33_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::GAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::GAsymmetric(super::super::field_header_size(34_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::HAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.atlas());
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.size() };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::HAsymmetric(super::super::field_header_size(35_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::IAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.atlas());
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.size() };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::IAsymmetric(super::super::field_header_size(36_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::JAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let payload = &(payload.len() as u64); (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::JAsymmetric(super::super::field_header_size(37_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::KAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (8_usize * payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::KAsymmetric(super::super::field_header_size(38_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::LAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload))));
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::LAsymmetric(super::super::field_header_size(39_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::MAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) })));
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::MAsymmetric(super::super::field_header_size(40_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::NAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.iter().fold(0_usize, |x, payload| x + (1_usize)));
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::NAsymmetric(super::super::field_header_size(41_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::OAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::OAsymmetric(super::super::field_header_size(42_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::PAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::PAsymmetric(super::super::field_header_size(43_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::QAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::QAsymmetric(super::super::field_header_size(44_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::RAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::RAsymmetric(super::super::field_header_size(45_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::SAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let payload = &(payload.len() as u64); (super::super::varint_size_from_value(*payload)) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::SAsymmetric(super::super::field_header_size(46_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::TAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (8_usize * payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::TAsymmetric(super::super::field_header_size(47_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::UAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload))))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::UAsymmetric(super::super::field_header_size(48_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::VAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) })))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::VAsymmetric(super::super::field_header_size(49_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::WAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (1_usize)))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::WAsymmetric(super::super::field_header_size(50_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::XAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::XAsymmetric(super::super::field_header_size(51_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::YAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::YAsymmetric(super::super::field_header_size(52_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::ZAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::ZAsymmetric(super::super::field_header_size(53_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::AaAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::AaAsymmetric(super::super::field_header_size(54_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::AOptional(ref fallback) => {
                        let payload = &();
                        let payload_atlas = (0_usize);
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::AOptional(super::super::field_header_size(56_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::BOptional(ref payload, ref fallback) => {
                        let payload_atlas = (if payload.to_bits() == 0_u64 { 0_usize } else { 8_usize });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::BOptional(super::super::field_header_size(57_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::COptional(ref payload, ref fallback) => {
                        let payload_atlas = (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::COptional(super::super::field_header_size(58_u64, payload_size, true) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::DOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::DOptional(super::super::field_header_size(59_u64, payload_size, true) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::EOptional(ref payload, ref fallback) => {
                        let payload_atlas = (if *payload { 1_usize } else { 0_usize });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::EOptional(super::super::field_header_size(60_u64, payload_size, true) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::FOptional(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::FOptional(super::super::field_header_size(61_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::GOptional(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::GOptional(super::super::field_header_size(62_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::HOptional(ref payload, ref fallback) => {
                        let payload_atlas = (payload.atlas());
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.size() };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::HOptional(super::super::field_header_size(63_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::IOptional(ref payload, ref fallback) => {
                        let payload_atlas = (payload.atlas());
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.size() };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::IOptional(super::super::field_header_size(64_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::JOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let payload = &(payload.len() as u64); (match *payload { 0_u64 => { 0_usize }, 1_u64..=567_382_630_219_903_u64 => { super::super::varint_size_from_value(*payload) }, 567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => { 8_usize } }) });
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::JOptional(super::super::field_header_size(65_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::KOptional(ref payload, ref fallback) => {
                        let payload_atlas = (8_usize * payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::KOptional(super::super::field_header_size(66_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::LOptional(ref payload, ref fallback) => {
                        let payload_atlas = (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload))));
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::LOptional(super::super::field_header_size(67_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::MOptional(ref payload, ref fallback) => {
                        let payload_atlas = (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) })));
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::MOptional(super::super::field_header_size(68_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::NOptional(ref payload, ref fallback) => {
                        let payload_atlas = (payload.iter().fold(0_usize, |x, payload| x + (1_usize)));
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::NOptional(super::super::field_header_size(69_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::OOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::OOptional(super::super::field_header_size(70_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::POptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::POptional(super::super::field_header_size(71_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::QOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::QOptional(super::super::field_header_size(72_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::ROptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::ROptional(super::super::field_header_size(73_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::SOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let payload = &(payload.len() as u64); (super::super::varint_size_from_value(*payload)) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::SOptional(super::super::field_header_size(74_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::TOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (8_usize * payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::TOptional(super::super::field_header_size(75_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::UOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (super::super::varint_size_from_value(*payload))))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::UOptional(super::super::field_header_size(76_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::VOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + ({ let zigzag = super::super::zigzag_encode(*payload); let payload = &zigzag; (super::super::varint_size_from_value(*payload)) })))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::VOptional(super::super::field_header_size(77_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::WOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| (payload.iter().fold(0_usize, |x, payload| x + (1_usize)))).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::WOptional(super::super::field_header_size(78_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::XOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::XOptional(super::super::field_header_size(79_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::YOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.len())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = *payload_atlas; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::YOptional(super::super::field_header_size(80_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::ZOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::ZOptional(super::super::field_header_size(81_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    BarOut::AaOptional(ref payload, ref fallback) => {
                        let payload_atlas = ({ let atlases = payload.iter().map(|payload| ({ let atlases = payload.iter().map(|payload| (payload.atlas())).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.size(); x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) })).collect::<Vec<_>>(); (atlases.iter().fold(0_usize, |x, payload_atlas| { let atlas_size = payload_atlas.0; x + super::super::varint_size_from_value(atlas_size as u64) + atlas_size }), atlases) });
                        let payload_size = { let payload_atlas = &payload_atlas; payload_atlas.0 };
                        let fallback_atlas = fallback.atlas();
                        BarAtlas::AaOptional(super::super::field_header_size(82_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &BarAtlas,
            ) -> ::std::io::Result<()> {
                match (self, atlas) {
                    (BarOut::ARequired, BarAtlas::ARequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 0_u64, *payload_atlas, false)?;
                        Ok(())
                    }
                    (BarOut::BRequired(payload), BarAtlas::BRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 1_u64, *payload_atlas, false)?;
                        if payload.to_bits() != 0_u64 {
                            writer.write_all(&payload.to_le_bytes())?;
                        }
                        Ok(())
                    }
                    (BarOut::CRequired(payload), BarAtlas::CRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 2_u64, *payload_atlas, true)?;
                        {
                            let varint = *payload;
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        Ok(())
                    }
                    (BarOut::DRequired(payload), BarAtlas::DRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 3_u64, *payload_atlas, true)?;
                        {
                            let varint = super::super::zigzag_encode(*payload);
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        Ok(())
                    }
                    (BarOut::ERequired(payload), BarAtlas::ERequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 4_u64, *payload_atlas, true)?;
                        {
                            let varint = *payload as u64;
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        Ok(())
                    }
                    (BarOut::FRequired(payload), BarAtlas::FRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 5_u64, *payload_atlas, false)?;
                        writer.write_all(payload)?;
                        Ok(())
                    }
                    (BarOut::GRequired(payload), BarAtlas::GRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 6_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        Ok(())
                    }
                    (BarOut::HRequired(payload), BarAtlas::HRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 7_u64, payload_atlas.size(), false)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                        Ok(())
                    }
                    (BarOut::IRequired(payload), BarAtlas::IRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 8_u64, payload_atlas.size(), false)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                        Ok(())
                    }
                    (BarOut::JRequired(payload), BarAtlas::JRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 9_u64, *payload_atlas, false)?;
                        {
                            let varint = payload.len() as u64 as u64;
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        Ok(())
                    }
                    (BarOut::KRequired(payload), BarAtlas::KRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 10_u64, *payload_atlas, false)?;
                        for payload in payload {
                            writer.write_all(&payload.to_le_bytes())?;
                        }
                        Ok(())
                    }
                    (BarOut::LRequired(payload), BarAtlas::LRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 11_u64, *payload_atlas, false)?;
                        for payload in payload {
                            {
                                let varint = *payload;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        Ok(())
                    }
                    (BarOut::MRequired(payload), BarAtlas::MRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 12_u64, *payload_atlas, false)?;
                        for payload in payload {
                            {
                                let varint = super::super::zigzag_encode(*payload);
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        Ok(())
                    }
                    (BarOut::NRequired(payload), BarAtlas::NRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 13_u64, *payload_atlas, false)?;
                        for payload in payload {
                            {
                                let varint = *payload as u64;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        Ok(())
                    }
                    (BarOut::ORequired(payload), BarAtlas::ORequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 14_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload)?;
                        }
                        Ok(())
                    }
                    (BarOut::PRequired(payload), BarAtlas::PRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 15_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload.as_bytes())?;
                        }
                        Ok(())
                    }
                    (BarOut::QRequired(payload), BarAtlas::QRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 16_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                        Ok(())
                    }
                    (BarOut::RRequired(payload), BarAtlas::RRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 17_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                        Ok(())
                    }
                    (BarOut::SRequired(payload), BarAtlas::SRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 18_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            {
                                let varint = payload.len() as u64 as u64;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        Ok(())
                    }
                    (BarOut::TRequired(payload), BarAtlas::TRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 19_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                writer.write_all(&payload.to_le_bytes())?;
                            }
                        }
                        Ok(())
                    }
                    (BarOut::URequired(payload), BarAtlas::URequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 20_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                {
                                    let varint = *payload;
                                    super::super::serialize_varint(varint, writer)?;
                                }
                            }
                        }
                        Ok(())
                    }
                    (BarOut::VRequired(payload), BarAtlas::VRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 21_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                {
                                    let varint = super::super::zigzag_encode(*payload);
                                    super::super::serialize_varint(varint, writer)?;
                                }
                            }
                        }
                        Ok(())
                    }
                    (BarOut::WRequired(payload), BarAtlas::WRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 22_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                {
                                    let varint = *payload as u64;
                                    super::super::serialize_varint(varint, writer)?;
                                }
                            }
                        }
                        Ok(())
                    }
                    (BarOut::XRequired(payload), BarAtlas::XRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 23_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(*payload_atlas as u64, writer)?;
                                writer.write_all(payload)?;
                            }
                        }
                        Ok(())
                    }
                    (BarOut::YRequired(payload), BarAtlas::YRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 24_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(*payload_atlas as u64, writer)?;
                                writer.write_all(payload.as_bytes())?;
                            }
                        }
                        Ok(())
                    }
                    (BarOut::ZRequired(payload), BarAtlas::ZRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 25_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                                payload.serialize_with_atlas(writer, payload_atlas)?;
                            }
                        }
                        Ok(())
                    }
                    (BarOut::AaRequired(payload), BarAtlas::AaRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 26_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                                payload.serialize_with_atlas(writer, payload_atlas)?;
                            }
                        }
                        Ok(())
                    }
                    (BarOut::AAsymmetric(fallback), BarAtlas::AAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 28_u64, *payload_atlas, false)?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::BAsymmetric(payload, fallback), BarAtlas::BAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 29_u64, *payload_atlas, false)?;
                        if payload.to_bits() != 0_u64 {
                            writer.write_all(&payload.to_le_bytes())?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::CAsymmetric(payload, fallback), BarAtlas::CAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 30_u64, *payload_atlas, true)?;
                        {
                            let varint = *payload;
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::DAsymmetric(payload, fallback), BarAtlas::DAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 31_u64, *payload_atlas, true)?;
                        {
                            let varint = super::super::zigzag_encode(*payload);
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::EAsymmetric(payload, fallback), BarAtlas::EAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 32_u64, *payload_atlas, true)?;
                        {
                            let varint = *payload as u64;
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::FAsymmetric(payload, fallback), BarAtlas::FAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 33_u64, *payload_atlas, false)?;
                        writer.write_all(payload)?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::GAsymmetric(payload, fallback), BarAtlas::GAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 34_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::HAsymmetric(payload, fallback), BarAtlas::HAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 35_u64, payload_atlas.size(), false)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::IAsymmetric(payload, fallback), BarAtlas::IAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 36_u64, payload_atlas.size(), false)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::JAsymmetric(payload, fallback), BarAtlas::JAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 37_u64, *payload_atlas, false)?;
                        {
                            let varint = payload.len() as u64 as u64;
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::KAsymmetric(payload, fallback), BarAtlas::KAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 38_u64, *payload_atlas, false)?;
                        for payload in payload {
                            writer.write_all(&payload.to_le_bytes())?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::LAsymmetric(payload, fallback), BarAtlas::LAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 39_u64, *payload_atlas, false)?;
                        for payload in payload {
                            {
                                let varint = *payload;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::MAsymmetric(payload, fallback), BarAtlas::MAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 40_u64, *payload_atlas, false)?;
                        for payload in payload {
                            {
                                let varint = super::super::zigzag_encode(*payload);
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::NAsymmetric(payload, fallback), BarAtlas::NAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 41_u64, *payload_atlas, false)?;
                        for payload in payload {
                            {
                                let varint = *payload as u64;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::OAsymmetric(payload, fallback), BarAtlas::OAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 42_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload)?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::PAsymmetric(payload, fallback), BarAtlas::PAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 43_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload.as_bytes())?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::QAsymmetric(payload, fallback), BarAtlas::QAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 44_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::RAsymmetric(payload, fallback), BarAtlas::RAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 45_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::SAsymmetric(payload, fallback), BarAtlas::SAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 46_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            {
                                let varint = payload.len() as u64 as u64;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::TAsymmetric(payload, fallback), BarAtlas::TAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 47_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                writer.write_all(&payload.to_le_bytes())?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::UAsymmetric(payload, fallback), BarAtlas::UAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 48_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                {
                                    let varint = *payload;
                                    super::super::serialize_varint(varint, writer)?;
                                }
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::VAsymmetric(payload, fallback), BarAtlas::VAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 49_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                {
                                    let varint = super::super::zigzag_encode(*payload);
                                    super::super::serialize_varint(varint, writer)?;
                                }
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::WAsymmetric(payload, fallback), BarAtlas::WAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 50_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                {
                                    let varint = *payload as u64;
                                    super::super::serialize_varint(varint, writer)?;
                                }
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::XAsymmetric(payload, fallback), BarAtlas::XAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 51_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(*payload_atlas as u64, writer)?;
                                writer.write_all(payload)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::YAsymmetric(payload, fallback), BarAtlas::YAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 52_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(*payload_atlas as u64, writer)?;
                                writer.write_all(payload.as_bytes())?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::ZAsymmetric(payload, fallback), BarAtlas::ZAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 53_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                                payload.serialize_with_atlas(writer, payload_atlas)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::AaAsymmetric(payload, fallback), BarAtlas::AaAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 54_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                                payload.serialize_with_atlas(writer, payload_atlas)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::AOptional(fallback), BarAtlas::AOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 56_u64, *payload_atlas, false)?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::BOptional(payload, fallback), BarAtlas::BOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 57_u64, *payload_atlas, false)?;
                        if payload.to_bits() != 0_u64 {
                            writer.write_all(&payload.to_le_bytes())?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::COptional(payload, fallback), BarAtlas::COptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 58_u64, *payload_atlas, true)?;
                        {
                            let varint = *payload;
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::DOptional(payload, fallback), BarAtlas::DOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 59_u64, *payload_atlas, true)?;
                        {
                            let varint = super::super::zigzag_encode(*payload);
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::EOptional(payload, fallback), BarAtlas::EOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 60_u64, *payload_atlas, true)?;
                        {
                            let varint = *payload as u64;
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::FOptional(payload, fallback), BarAtlas::FOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 61_u64, *payload_atlas, false)?;
                        writer.write_all(payload)?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::GOptional(payload, fallback), BarAtlas::GOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 62_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::HOptional(payload, fallback), BarAtlas::HOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 63_u64, payload_atlas.size(), false)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::IOptional(payload, fallback), BarAtlas::IOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 64_u64, payload_atlas.size(), false)?;
                        payload.serialize_with_atlas(writer, payload_atlas)?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::JOptional(payload, fallback), BarAtlas::JOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 65_u64, *payload_atlas, false)?;
                        {
                            let varint = payload.len() as u64 as u64;
                            match varint {
                                0_u64 => {}
                                1_u64..=567_382_630_219_903_u64 => super::super::serialize_varint(varint, writer)?,
                                567_382_630_219_904_u64..=18_446_744_073_709_551_615_u64 => writer.write_all(&varint.to_le_bytes())?,
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::KOptional(payload, fallback), BarAtlas::KOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 66_u64, *payload_atlas, false)?;
                        for payload in payload {
                            writer.write_all(&payload.to_le_bytes())?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::LOptional(payload, fallback), BarAtlas::LOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 67_u64, *payload_atlas, false)?;
                        for payload in payload {
                            {
                                let varint = *payload;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::MOptional(payload, fallback), BarAtlas::MOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 68_u64, *payload_atlas, false)?;
                        for payload in payload {
                            {
                                let varint = super::super::zigzag_encode(*payload);
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::NOptional(payload, fallback), BarAtlas::NOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 69_u64, *payload_atlas, false)?;
                        for payload in payload {
                            {
                                let varint = *payload as u64;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::OOptional(payload, fallback), BarAtlas::OOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 70_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload)?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::POptional(payload, fallback), BarAtlas::POptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 71_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            writer.write_all(payload.as_bytes())?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::QOptional(payload, fallback), BarAtlas::QOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 72_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::ROptional(payload, fallback), BarAtlas::ROptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 73_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                            payload.serialize_with_atlas(writer, payload_atlas)?;
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::SOptional(payload, fallback), BarAtlas::SOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 74_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            {
                                let varint = payload.len() as u64 as u64;
                                super::super::serialize_varint(varint, writer)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::TOptional(payload, fallback), BarAtlas::TOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 75_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                writer.write_all(&payload.to_le_bytes())?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::UOptional(payload, fallback), BarAtlas::UOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 76_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                {
                                    let varint = *payload;
                                    super::super::serialize_varint(varint, writer)?;
                                }
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::VOptional(payload, fallback), BarAtlas::VOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 77_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                {
                                    let varint = super::super::zigzag_encode(*payload);
                                    super::super::serialize_varint(varint, writer)?;
                                }
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::WOptional(payload, fallback), BarAtlas::WOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 78_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(*payload_atlas as u64, writer)?;
                            for payload in payload {
                                {
                                    let varint = *payload as u64;
                                    super::super::serialize_varint(varint, writer)?;
                                }
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::XOptional(payload, fallback), BarAtlas::XOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 79_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(*payload_atlas as u64, writer)?;
                                writer.write_all(payload)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::YOptional(payload, fallback), BarAtlas::YOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 80_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(*payload_atlas as u64, writer)?;
                                writer.write_all(payload.as_bytes())?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::ZOptional(payload, fallback), BarAtlas::ZOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 81_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                                payload.serialize_with_atlas(writer, payload_atlas)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (BarOut::AaOptional(payload, fallback), BarAtlas::AaOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 82_u64, payload_atlas.0, false)?;
                        for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                            super::super::serialize_varint(payload_atlas.0 as u64, writer)?;
                            for (payload, payload_atlas) in payload.iter().zip(payload_atlas.1.iter()) {
                                super::super::serialize_varint(payload_atlas.size() as u64, writer)?;
                                payload.serialize_with_atlas(writer, payload_atlas)?;
                            }
                        }
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (_, _) => panic!(),
                }
            }
        }

        impl BarAtlas {
            pub fn size(&self) -> usize {
                match *self {
                    BarAtlas::ARequired(ref size, _) => *size,
                    BarAtlas::BRequired(ref size, _) => *size,
                    BarAtlas::CRequired(ref size, _) => *size,
                    BarAtlas::DRequired(ref size, _) => *size,
                    BarAtlas::ERequired(ref size, _) => *size,
                    BarAtlas::FRequired(ref size, _) => *size,
                    BarAtlas::GRequired(ref size, _) => *size,
                    BarAtlas::HRequired(ref size, _) => *size,
                    BarAtlas::IRequired(ref size, _) => *size,
                    BarAtlas::JRequired(ref size, _) => *size,
                    BarAtlas::KRequired(ref size, _) => *size,
                    BarAtlas::LRequired(ref size, _) => *size,
                    BarAtlas::MRequired(ref size, _) => *size,
                    BarAtlas::NRequired(ref size, _) => *size,
                    BarAtlas::ORequired(ref size, _) => *size,
                    BarAtlas::PRequired(ref size, _) => *size,
                    BarAtlas::QRequired(ref size, _) => *size,
                    BarAtlas::RRequired(ref size, _) => *size,
                    BarAtlas::SRequired(ref size, _) => *size,
                    BarAtlas::TRequired(ref size, _) => *size,
                    BarAtlas::URequired(ref size, _) => *size,
                    BarAtlas::VRequired(ref size, _) => *size,
                    BarAtlas::WRequired(ref size, _) => *size,
                    BarAtlas::XRequired(ref size, _) => *size,
                    BarAtlas::YRequired(ref size, _) => *size,
                    BarAtlas::ZRequired(ref size, _) => *size,
                    BarAtlas::AaRequired(ref size, _) => *size,
                    BarAtlas::AAsymmetric(ref size, _, _) => *size,
                    BarAtlas::BAsymmetric(ref size, _, _) => *size,
                    BarAtlas::CAsymmetric(ref size, _, _) => *size,
                    BarAtlas::DAsymmetric(ref size, _, _) => *size,
                    BarAtlas::EAsymmetric(ref size, _, _) => *size,
                    BarAtlas::FAsymmetric(ref size, _, _) => *size,
                    BarAtlas::GAsymmetric(ref size, _, _) => *size,
                    BarAtlas::HAsymmetric(ref size, _, _) => *size,
                    BarAtlas::IAsymmetric(ref size, _, _) => *size,
                    BarAtlas::JAsymmetric(ref size, _, _) => *size,
                    BarAtlas::KAsymmetric(ref size, _, _) => *size,
                    BarAtlas::LAsymmetric(ref size, _, _) => *size,
                    BarAtlas::MAsymmetric(ref size, _, _) => *size,
                    BarAtlas::NAsymmetric(ref size, _, _) => *size,
                    BarAtlas::OAsymmetric(ref size, _, _) => *size,
                    BarAtlas::PAsymmetric(ref size, _, _) => *size,
                    BarAtlas::QAsymmetric(ref size, _, _) => *size,
                    BarAtlas::RAsymmetric(ref size, _, _) => *size,
                    BarAtlas::SAsymmetric(ref size, _, _) => *size,
                    BarAtlas::TAsymmetric(ref size, _, _) => *size,
                    BarAtlas::UAsymmetric(ref size, _, _) => *size,
                    BarAtlas::VAsymmetric(ref size, _, _) => *size,
                    BarAtlas::WAsymmetric(ref size, _, _) => *size,
                    BarAtlas::XAsymmetric(ref size, _, _) => *size,
                    BarAtlas::YAsymmetric(ref size, _, _) => *size,
                    BarAtlas::ZAsymmetric(ref size, _, _) => *size,
                    BarAtlas::AaAsymmetric(ref size, _, _) => *size,
                    BarAtlas::AOptional(ref size, _, _) => *size,
                    BarAtlas::BOptional(ref size, _, _) => *size,
                    BarAtlas::COptional(ref size, _, _) => *size,
                    BarAtlas::DOptional(ref size, _, _) => *size,
                    BarAtlas::EOptional(ref size, _, _) => *size,
                    BarAtlas::FOptional(ref size, _, _) => *size,
                    BarAtlas::GOptional(ref size, _, _) => *size,
                    BarAtlas::HOptional(ref size, _, _) => *size,
                    BarAtlas::IOptional(ref size, _, _) => *size,
                    BarAtlas::JOptional(ref size, _, _) => *size,
                    BarAtlas::KOptional(ref size, _, _) => *size,
                    BarAtlas::LOptional(ref size, _, _) => *size,
                    BarAtlas::MOptional(ref size, _, _) => *size,
                    BarAtlas::NOptional(ref size, _, _) => *size,
                    BarAtlas::OOptional(ref size, _, _) => *size,
                    BarAtlas::POptional(ref size, _, _) => *size,
                    BarAtlas::QOptional(ref size, _, _) => *size,
                    BarAtlas::ROptional(ref size, _, _) => *size,
                    BarAtlas::SOptional(ref size, _, _) => *size,
                    BarAtlas::TOptional(ref size, _, _) => *size,
                    BarAtlas::UOptional(ref size, _, _) => *size,
                    BarAtlas::VOptional(ref size, _, _) => *size,
                    BarAtlas::WOptional(ref size, _, _) => *size,
                    BarAtlas::XOptional(ref size, _, _) => *size,
                    BarAtlas::YOptional(ref size, _, _) => *size,
                    BarAtlas::ZOptional(ref size, _, _) => *size,
                    BarAtlas::AaOptional(ref size, _, _) => *size,
                }
            }
        }
    }
}

pub mod degenerate {
    pub mod types {
        #[derive(Clone, Debug)]
        pub struct EmptyStructAtlas {
            pub _size: usize,
        }

        #[derive(Clone, Debug)]
        pub struct EmptyStructOut {
        }

        #[derive(Clone, Debug)]
        pub struct EmptyStructIn {
        }

        impl super::super::Serialize for EmptyStructOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for EmptyStructIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                loop {
                    let (index, payload_size) = match super::super::deserialize_field_header(&mut *reader) {
                        Ok(header) => header,
                        Err(err) => {
                            if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                break;
                            }

                            return Err(err);
                        }
                    };

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }

                Ok(EmptyStructIn {
                })
            }
        }

        impl From<EmptyStructOut> for EmptyStructIn {
            fn from(message: EmptyStructOut) -> Self {
                EmptyStructIn {
                }
            }
        }

        impl EmptyStructOut {
            pub fn atlas(&self) -> EmptyStructAtlas {
                EmptyStructAtlas {
                    _size: 0,
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &EmptyStructAtlas,
            ) -> ::std::io::Result<()> {
                Ok(())
            }
        }

        impl EmptyStructAtlas {
            pub fn size(&self) -> usize {
                self._size
            }
        }

        #[derive(Clone, Debug)]
        pub enum EmptyChoiceAtlas {
        }

        #[derive(Clone, Debug)]
        pub enum EmptyChoiceOut {
        }

        #[derive(Clone, Debug)]
        pub enum EmptyChoiceIn {
        }

        impl super::super::Serialize for EmptyChoiceOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for EmptyChoiceIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                loop {
                    let (index, payload_size) = super::super::deserialize_field_header(&mut *reader)?;

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }
            }
        }

        impl From<EmptyChoiceOut> for EmptyChoiceIn {
            fn from(message: EmptyChoiceOut) -> Self {
                match message {
                }
            }
        }

        impl EmptyChoiceOut {
            pub fn atlas(&self) -> EmptyChoiceAtlas {
                match *self {
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &EmptyChoiceAtlas,
            ) -> ::std::io::Result<()> {
                match (self, atlas) {
                    (_, _) => panic!(),
                }
            }
        }

        impl EmptyChoiceAtlas {
            pub fn size(&self) -> usize {
                match *self {
                }
            }
        }
    }
}

pub mod schema_evolution {
    pub mod after {
        #[derive(Clone, Debug)]
        pub struct ExampleStructAtlas {
            pub _size: usize,
            pub required_to_required: usize,
            pub required_to_asymmetric: usize,
            pub required_to_optional: Option<usize>,
            pub asymmetric_to_required: usize,
            pub asymmetric_to_asymmetric: usize,
            pub asymmetric_to_optional: Option<usize>,
            pub optional_to_required: usize,
            pub optional_to_asymmetric: usize,
            pub optional_to_optional: Option<usize>,
            pub nonexistent_to_asymmetric: usize,
            pub nonexistent_to_optional: Option<usize>,
        }

        #[derive(Clone, Debug)]
        pub struct ExampleStructOut {
            pub required_to_required: String,
            pub required_to_asymmetric: String,
            pub required_to_optional: Option<String>,
            pub asymmetric_to_required: String,
            pub asymmetric_to_asymmetric: String,
            pub asymmetric_to_optional: Option<String>,
            pub optional_to_required: String,
            pub optional_to_asymmetric: String,
            pub optional_to_optional: Option<String>,
            pub nonexistent_to_asymmetric: (),
            pub nonexistent_to_optional: Option<()>,
        }

        #[derive(Clone, Debug)]
        pub struct ExampleStructIn {
            pub required_to_required: String,
            pub required_to_asymmetric: Option<String>,
            pub required_to_optional: Option<String>,
            pub asymmetric_to_required: String,
            pub asymmetric_to_asymmetric: Option<String>,
            pub asymmetric_to_optional: Option<String>,
            pub optional_to_required: String,
            pub optional_to_asymmetric: Option<String>,
            pub optional_to_optional: Option<String>,
            pub nonexistent_to_asymmetric: Option<()>,
            pub nonexistent_to_optional: Option<()>,
        }

        impl super::super::Serialize for ExampleStructOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for ExampleStructIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                let mut _required_to_required: Option<String> = None;
                let mut _required_to_asymmetric: Option<String> = None;
                let mut _required_to_optional: Option<String> = None;
                let mut _asymmetric_to_required: Option<String> = None;
                let mut _asymmetric_to_asymmetric: Option<String> = None;
                let mut _asymmetric_to_optional: Option<String> = None;
                let mut _optional_to_required: Option<String> = None;
                let mut _optional_to_asymmetric: Option<String> = None;
                let mut _optional_to_optional: Option<String> = None;
                let mut _nonexistent_to_asymmetric: Option<()> = None;
                let mut _nonexistent_to_optional: Option<()> = None;

                loop {
                    let (index, payload_size) = match super::super::deserialize_field_header(&mut *reader) {
                        Ok(header) => header,
                        Err(err) => {
                            if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                break;
                            }

                            return Err(err);
                        }
                    };

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        0 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _required_to_required.get_or_insert(payload);
                        }
                        1 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _required_to_asymmetric.get_or_insert(payload);
                        }
                        2 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _required_to_optional.get_or_insert(payload);
                        }
                        4 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _asymmetric_to_required.get_or_insert(payload);
                        }
                        5 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _asymmetric_to_asymmetric.get_or_insert(payload);
                        }
                        6 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _asymmetric_to_optional.get_or_insert(payload);
                        }
                        8 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _optional_to_required.get_or_insert(payload);
                        }
                        9 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _optional_to_asymmetric.get_or_insert(payload);
                        }
                        10 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _optional_to_optional.get_or_insert(payload);
                        }
                        13 => {
                            let payload = ();
                            _nonexistent_to_asymmetric.get_or_insert(payload);
                        }
                        14 => {
                            let payload = ();
                            _nonexistent_to_optional.get_or_insert(payload);
                        }
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }

                if _required_to_required.is_none()
                    || _asymmetric_to_required.is_none()
                    || _optional_to_required.is_none() {
                    return Err(::std::io::Error::new(
                        ::std::io::ErrorKind::InvalidData,
                        super::super::MISSING_FIELDS_ERROR_MESSAGE,
                    ));
                }

                Ok(ExampleStructIn {
                    required_to_required: _required_to_required.unwrap(),
                    required_to_asymmetric: _required_to_asymmetric,
                    required_to_optional: _required_to_optional,
                    asymmetric_to_required: _asymmetric_to_required.unwrap(),
                    asymmetric_to_asymmetric: _asymmetric_to_asymmetric,
                    asymmetric_to_optional: _asymmetric_to_optional,
                    optional_to_required: _optional_to_required.unwrap(),
                    optional_to_asymmetric: _optional_to_asymmetric,
                    optional_to_optional: _optional_to_optional,
                    nonexistent_to_asymmetric: _nonexistent_to_asymmetric,
                    nonexistent_to_optional: _nonexistent_to_optional,
                })
            }
        }

        impl From<ExampleStructOut> for ExampleStructIn {
            fn from(message: ExampleStructOut) -> Self {
                ExampleStructIn {
                    required_to_required: message.required_to_required.into(),
                    required_to_asymmetric: Some(message.required_to_asymmetric.into()),
                    required_to_optional: message.required_to_optional.map(|payload| payload.into()),
                    asymmetric_to_required: message.asymmetric_to_required.into(),
                    asymmetric_to_asymmetric: Some(message.asymmetric_to_asymmetric.into()),
                    asymmetric_to_optional: message.asymmetric_to_optional.map(|payload| payload.into()),
                    optional_to_required: message.optional_to_required.into(),
                    optional_to_asymmetric: Some(message.optional_to_asymmetric.into()),
                    optional_to_optional: message.optional_to_optional.map(|payload| payload.into()),
                    nonexistent_to_asymmetric: Some(message.nonexistent_to_asymmetric.into()),
                    nonexistent_to_optional: message.nonexistent_to_optional.map(|payload| payload.into()),
                }
            }
        }

        impl ExampleStructOut {
            pub fn atlas(&self) -> ExampleStructAtlas {
                let _required_to_required = { let payload = &self.required_to_required; (payload.len()) };
                let _required_to_asymmetric = { let payload = &self.required_to_asymmetric; (payload.len()) };
                let _required_to_optional = self.required_to_optional.as_ref().map(|payload| (payload.len()));
                let _asymmetric_to_required = { let payload = &self.asymmetric_to_required; (payload.len()) };
                let _asymmetric_to_asymmetric = { let payload = &self.asymmetric_to_asymmetric; (payload.len()) };
                let _asymmetric_to_optional = self.asymmetric_to_optional.as_ref().map(|payload| (payload.len()));
                let _optional_to_required = { let payload = &self.optional_to_required; (payload.len()) };
                let _optional_to_asymmetric = { let payload = &self.optional_to_asymmetric; (payload.len()) };
                let _optional_to_optional = self.optional_to_optional.as_ref().map(|payload| (payload.len()));
                let _nonexistent_to_asymmetric = { let payload = &self.nonexistent_to_asymmetric; (0_usize) };
                let _nonexistent_to_optional = self.nonexistent_to_optional.as_ref().map(|payload| (0_usize));

                ExampleStructAtlas {
                    _size:
                        { let payload_atlas = &_required_to_required; let payload_size = *payload_atlas; super::super::field_header_size(0_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_required_to_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(1_u64, payload_size, false) + payload_size }
                        + _required_to_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(2_u64, payload_size, false) + payload_size })
                        + { let payload_atlas = &_asymmetric_to_required; let payload_size = *payload_atlas; super::super::field_header_size(4_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_asymmetric_to_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(5_u64, payload_size, false) + payload_size }
                        + _asymmetric_to_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(6_u64, payload_size, false) + payload_size })
                        + { let payload_atlas = &_optional_to_required; let payload_size = *payload_atlas; super::super::field_header_size(8_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_optional_to_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(9_u64, payload_size, false) + payload_size }
                        + _optional_to_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(10_u64, payload_size, false) + payload_size })
                        + { let payload_atlas = &_nonexistent_to_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(13_u64, payload_size, false) + payload_size }
                        + _nonexistent_to_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(14_u64, payload_size, false) + payload_size }),
                    required_to_required: _required_to_required,
                    required_to_asymmetric: _required_to_asymmetric,
                    required_to_optional: _required_to_optional,
                    asymmetric_to_required: _asymmetric_to_required,
                    asymmetric_to_asymmetric: _asymmetric_to_asymmetric,
                    asymmetric_to_optional: _asymmetric_to_optional,
                    optional_to_required: _optional_to_required,
                    optional_to_asymmetric: _optional_to_asymmetric,
                    optional_to_optional: _optional_to_optional,
                    nonexistent_to_asymmetric: _nonexistent_to_asymmetric,
                    nonexistent_to_optional: _nonexistent_to_optional,
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &ExampleStructAtlas,
            ) -> ::std::io::Result<()> {
                {
                    let payload = &self.required_to_required;
                    let payload_atlas = &atlas.required_to_required;
                    super::super::serialize_field_header(writer, 0_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.required_to_asymmetric;
                    let payload_atlas = &atlas.required_to_asymmetric;
                    super::super::serialize_field_header(writer, 1_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.required_to_optional, &atlas.required_to_optional) {
                    super::super::serialize_field_header(writer, 2_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.asymmetric_to_required;
                    let payload_atlas = &atlas.asymmetric_to_required;
                    super::super::serialize_field_header(writer, 4_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.asymmetric_to_asymmetric;
                    let payload_atlas = &atlas.asymmetric_to_asymmetric;
                    super::super::serialize_field_header(writer, 5_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.asymmetric_to_optional, &atlas.asymmetric_to_optional) {
                    super::super::serialize_field_header(writer, 6_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.optional_to_required;
                    let payload_atlas = &atlas.optional_to_required;
                    super::super::serialize_field_header(writer, 8_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.optional_to_asymmetric;
                    let payload_atlas = &atlas.optional_to_asymmetric;
                    super::super::serialize_field_header(writer, 9_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.optional_to_optional, &atlas.optional_to_optional) {
                    super::super::serialize_field_header(writer, 10_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.nonexistent_to_asymmetric;
                    let payload_atlas = &atlas.nonexistent_to_asymmetric;
                    super::super::serialize_field_header(writer, 13_u64, *payload_atlas, false)?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.nonexistent_to_optional, &atlas.nonexistent_to_optional) {
                    super::super::serialize_field_header(writer, 14_u64, *payload_atlas, false)?;
                }

                Ok(())
            }
        }

        impl ExampleStructAtlas {
            pub fn size(&self) -> usize {
                self._size
            }
        }

        #[derive(Clone, Debug)]
        pub enum ExampleChoiceAtlas {
            RequiredToRequired(usize, usize),
            RequiredToAsymmetric(usize, usize, Box<ExampleChoiceAtlas>),
            AsymmetricToRequired(usize, usize),
            AsymmetricToAsymmetric(usize, usize, Box<ExampleChoiceAtlas>),
            AsymmetricToOptional(usize, usize, Box<ExampleChoiceAtlas>),
            OptionalToRequired(usize, usize),
            OptionalToAsymmetric(usize, usize, Box<ExampleChoiceAtlas>),
            OptionalToOptional(usize, usize, Box<ExampleChoiceAtlas>),
            NonexistentToRequired(usize, usize),
            NonexistentToAsymmetric(usize, usize, Box<ExampleChoiceAtlas>),
            NonexistentToOptional(usize, usize, Box<ExampleChoiceAtlas>),
        }

        #[derive(Clone, Debug)]
        pub enum ExampleChoiceOut {
            RequiredToRequired(String),
            RequiredToAsymmetric(String, Box<ExampleChoiceOut>),
            AsymmetricToRequired(String),
            AsymmetricToAsymmetric(String, Box<ExampleChoiceOut>),
            AsymmetricToOptional(String, Box<ExampleChoiceOut>),
            OptionalToRequired(String),
            OptionalToAsymmetric(String, Box<ExampleChoiceOut>),
            OptionalToOptional(String, Box<ExampleChoiceOut>),
            NonexistentToRequired,
            NonexistentToAsymmetric(Box<ExampleChoiceOut>),
            NonexistentToOptional(Box<ExampleChoiceOut>),
        }

        #[derive(Clone, Debug)]
        pub enum ExampleChoiceIn {
            RequiredToRequired(String),
            RequiredToAsymmetric(String),
            AsymmetricToRequired(String),
            AsymmetricToAsymmetric(String),
            AsymmetricToOptional(String, Box<ExampleChoiceIn>),
            OptionalToRequired(String),
            OptionalToAsymmetric(String),
            OptionalToOptional(String, Box<ExampleChoiceIn>),
            NonexistentToRequired,
            NonexistentToAsymmetric,
            NonexistentToOptional(Box<ExampleChoiceIn>),
        }

        impl super::super::Serialize for ExampleChoiceOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for ExampleChoiceIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                loop {
                    let (index, payload_size) = super::super::deserialize_field_header(&mut *reader)?;

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        0 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::RequiredToRequired(payload));
                        }
                        1 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::RequiredToAsymmetric(payload));
                        }
                        4 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::AsymmetricToRequired(payload));
                        }
                        5 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::AsymmetricToAsymmetric(payload));
                        }
                        6 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            let fallback = Box::new(<ExampleChoiceIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(ExampleChoiceIn::AsymmetricToOptional(payload, fallback));
                        }
                        8 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::OptionalToRequired(payload));
                        }
                        9 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::OptionalToAsymmetric(payload));
                        }
                        10 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            let fallback = Box::new(<ExampleChoiceIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(ExampleChoiceIn::OptionalToOptional(payload, fallback));
                        }
                        12 => {
                            let payload = ();
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::NonexistentToRequired);
                        }
                        13 => {
                            let payload = ();
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::NonexistentToAsymmetric);
                        }
                        14 => {
                            let payload = ();
                            let fallback = Box::new(<ExampleChoiceIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(ExampleChoiceIn::NonexistentToOptional(fallback));
                        }
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }
            }
        }

        impl From<ExampleChoiceOut> for ExampleChoiceIn {
            fn from(message: ExampleChoiceOut) -> Self {
                match message {
                    ExampleChoiceOut::RequiredToRequired(payload) => ExampleChoiceIn::RequiredToRequired(payload.into()),
                    ExampleChoiceOut::RequiredToAsymmetric(payload, fallback) => ExampleChoiceIn::RequiredToAsymmetric(payload.into()),
                    ExampleChoiceOut::AsymmetricToRequired(payload) => ExampleChoiceIn::AsymmetricToRequired(payload.into()),
                    ExampleChoiceOut::AsymmetricToAsymmetric(payload, fallback) => ExampleChoiceIn::AsymmetricToAsymmetric(payload.into()),
                    ExampleChoiceOut::AsymmetricToOptional(payload, fallback) => ExampleChoiceIn::AsymmetricToOptional(payload.into(), Box::new((*fallback).into())),
                    ExampleChoiceOut::OptionalToRequired(payload) => ExampleChoiceIn::OptionalToRequired(payload.into()),
                    ExampleChoiceOut::OptionalToAsymmetric(payload, fallback) => ExampleChoiceIn::OptionalToAsymmetric(payload.into()),
                    ExampleChoiceOut::OptionalToOptional(payload, fallback) => ExampleChoiceIn::OptionalToOptional(payload.into(), Box::new((*fallback).into())),
                    ExampleChoiceOut::NonexistentToRequired => ExampleChoiceIn::NonexistentToRequired,
                    ExampleChoiceOut::NonexistentToAsymmetric(fallback) => ExampleChoiceIn::NonexistentToAsymmetric,
                    ExampleChoiceOut::NonexistentToOptional(fallback) => ExampleChoiceIn::NonexistentToOptional(Box::new((*fallback).into())),
                }
            }
        }

        impl ExampleChoiceOut {
            pub fn atlas(&self) -> ExampleChoiceAtlas {
                match *self {
                    ExampleChoiceOut::RequiredToRequired(ref payload) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        ExampleChoiceAtlas::RequiredToRequired(super::super::field_header_size(0_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    ExampleChoiceOut::RequiredToAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::RequiredToAsymmetric(super::super::field_header_size(1_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::AsymmetricToRequired(ref payload) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        ExampleChoiceAtlas::AsymmetricToRequired(super::super::field_header_size(4_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    ExampleChoiceOut::AsymmetricToAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::AsymmetricToAsymmetric(super::super::field_header_size(5_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::AsymmetricToOptional(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::AsymmetricToOptional(super::super::field_header_size(6_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::OptionalToRequired(ref payload) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        ExampleChoiceAtlas::OptionalToRequired(super::super::field_header_size(8_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    ExampleChoiceOut::OptionalToAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::OptionalToAsymmetric(super::super::field_header_size(9_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::OptionalToOptional(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::OptionalToOptional(super::super::field_header_size(10_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::NonexistentToRequired => {
                        let payload = &();
                        let payload_atlas = (0_usize);
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        ExampleChoiceAtlas::NonexistentToRequired(super::super::field_header_size(12_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    ExampleChoiceOut::NonexistentToAsymmetric(ref fallback) => {
                        let payload = &();
                        let payload_atlas = (0_usize);
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::NonexistentToAsymmetric(super::super::field_header_size(13_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::NonexistentToOptional(ref fallback) => {
                        let payload = &();
                        let payload_atlas = (0_usize);
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::NonexistentToOptional(super::super::field_header_size(14_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &ExampleChoiceAtlas,
            ) -> ::std::io::Result<()> {
                match (self, atlas) {
                    (ExampleChoiceOut::RequiredToRequired(payload), ExampleChoiceAtlas::RequiredToRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 0_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        Ok(())
                    }
                    (ExampleChoiceOut::RequiredToAsymmetric(payload, fallback), ExampleChoiceAtlas::RequiredToAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 1_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::AsymmetricToRequired(payload), ExampleChoiceAtlas::AsymmetricToRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 4_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        Ok(())
                    }
                    (ExampleChoiceOut::AsymmetricToAsymmetric(payload, fallback), ExampleChoiceAtlas::AsymmetricToAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 5_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::AsymmetricToOptional(payload, fallback), ExampleChoiceAtlas::AsymmetricToOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 6_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::OptionalToRequired(payload), ExampleChoiceAtlas::OptionalToRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 8_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        Ok(())
                    }
                    (ExampleChoiceOut::OptionalToAsymmetric(payload, fallback), ExampleChoiceAtlas::OptionalToAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 9_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::OptionalToOptional(payload, fallback), ExampleChoiceAtlas::OptionalToOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 10_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::NonexistentToRequired, ExampleChoiceAtlas::NonexistentToRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 12_u64, *payload_atlas, false)?;
                        Ok(())
                    }
                    (ExampleChoiceOut::NonexistentToAsymmetric(fallback), ExampleChoiceAtlas::NonexistentToAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 13_u64, *payload_atlas, false)?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::NonexistentToOptional(fallback), ExampleChoiceAtlas::NonexistentToOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 14_u64, *payload_atlas, false)?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (_, _) => panic!(),
                }
            }
        }

        impl ExampleChoiceAtlas {
            pub fn size(&self) -> usize {
                match *self {
                    ExampleChoiceAtlas::RequiredToRequired(ref size, _) => *size,
                    ExampleChoiceAtlas::RequiredToAsymmetric(ref size, _, _) => *size,
                    ExampleChoiceAtlas::AsymmetricToRequired(ref size, _) => *size,
                    ExampleChoiceAtlas::AsymmetricToAsymmetric(ref size, _, _) => *size,
                    ExampleChoiceAtlas::AsymmetricToOptional(ref size, _, _) => *size,
                    ExampleChoiceAtlas::OptionalToRequired(ref size, _) => *size,
                    ExampleChoiceAtlas::OptionalToAsymmetric(ref size, _, _) => *size,
                    ExampleChoiceAtlas::OptionalToOptional(ref size, _, _) => *size,
                    ExampleChoiceAtlas::NonexistentToRequired(ref size, _) => *size,
                    ExampleChoiceAtlas::NonexistentToAsymmetric(ref size, _, _) => *size,
                    ExampleChoiceAtlas::NonexistentToOptional(ref size, _, _) => *size,
                }
            }
        }
    }

    pub mod before {
        #[derive(Clone, Debug)]
        pub struct ExampleStructAtlas {
            pub _size: usize,
            pub required_to_required: usize,
            pub required_to_asymmetric: usize,
            pub required_to_optional: usize,
            pub required_to_nonexistent: usize,
            pub asymmetric_to_required: usize,
            pub asymmetric_to_asymmetric: usize,
            pub asymmetric_to_optional: usize,
            pub asymmetric_to_nonexistent: usize,
            pub optional_to_required: Option<usize>,
            pub optional_to_asymmetric: Option<usize>,
            pub optional_to_optional: Option<usize>,
            pub optional_to_nonexistent: Option<usize>,
        }

        #[derive(Clone, Debug)]
        pub struct ExampleStructOut {
            pub required_to_required: String,
            pub required_to_asymmetric: String,
            pub required_to_optional: String,
            pub required_to_nonexistent: String,
            pub asymmetric_to_required: String,
            pub asymmetric_to_asymmetric: String,
            pub asymmetric_to_optional: String,
            pub asymmetric_to_nonexistent: String,
            pub optional_to_required: Option<String>,
            pub optional_to_asymmetric: Option<String>,
            pub optional_to_optional: Option<String>,
            pub optional_to_nonexistent: Option<String>,
        }

        #[derive(Clone, Debug)]
        pub struct ExampleStructIn {
            pub required_to_required: String,
            pub required_to_asymmetric: String,
            pub required_to_optional: String,
            pub required_to_nonexistent: String,
            pub asymmetric_to_required: Option<String>,
            pub asymmetric_to_asymmetric: Option<String>,
            pub asymmetric_to_optional: Option<String>,
            pub asymmetric_to_nonexistent: Option<String>,
            pub optional_to_required: Option<String>,
            pub optional_to_asymmetric: Option<String>,
            pub optional_to_optional: Option<String>,
            pub optional_to_nonexistent: Option<String>,
        }

        impl super::super::Serialize for ExampleStructOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for ExampleStructIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                let mut _required_to_required: Option<String> = None;
                let mut _required_to_asymmetric: Option<String> = None;
                let mut _required_to_optional: Option<String> = None;
                let mut _required_to_nonexistent: Option<String> = None;
                let mut _asymmetric_to_required: Option<String> = None;
                let mut _asymmetric_to_asymmetric: Option<String> = None;
                let mut _asymmetric_to_optional: Option<String> = None;
                let mut _asymmetric_to_nonexistent: Option<String> = None;
                let mut _optional_to_required: Option<String> = None;
                let mut _optional_to_asymmetric: Option<String> = None;
                let mut _optional_to_optional: Option<String> = None;
                let mut _optional_to_nonexistent: Option<String> = None;

                loop {
                    let (index, payload_size) = match super::super::deserialize_field_header(&mut *reader) {
                        Ok(header) => header,
                        Err(err) => {
                            if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                break;
                            }

                            return Err(err);
                        }
                    };

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        0 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _required_to_required.get_or_insert(payload);
                        }
                        1 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _required_to_asymmetric.get_or_insert(payload);
                        }
                        2 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _required_to_optional.get_or_insert(payload);
                        }
                        3 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _required_to_nonexistent.get_or_insert(payload);
                        }
                        4 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _asymmetric_to_required.get_or_insert(payload);
                        }
                        5 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _asymmetric_to_asymmetric.get_or_insert(payload);
                        }
                        6 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _asymmetric_to_optional.get_or_insert(payload);
                        }
                        7 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _asymmetric_to_nonexistent.get_or_insert(payload);
                        }
                        8 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _optional_to_required.get_or_insert(payload);
                        }
                        9 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _optional_to_asymmetric.get_or_insert(payload);
                        }
                        10 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _optional_to_optional.get_or_insert(payload);
                        }
                        11 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _optional_to_nonexistent.get_or_insert(payload);
                        }
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }

                if _required_to_required.is_none()
                    || _required_to_asymmetric.is_none()
                    || _required_to_optional.is_none()
                    || _required_to_nonexistent.is_none() {
                    return Err(::std::io::Error::new(
                        ::std::io::ErrorKind::InvalidData,
                        super::super::MISSING_FIELDS_ERROR_MESSAGE,
                    ));
                }

                Ok(ExampleStructIn {
                    required_to_required: _required_to_required.unwrap(),
                    required_to_asymmetric: _required_to_asymmetric.unwrap(),
                    required_to_optional: _required_to_optional.unwrap(),
                    required_to_nonexistent: _required_to_nonexistent.unwrap(),
                    asymmetric_to_required: _asymmetric_to_required,
                    asymmetric_to_asymmetric: _asymmetric_to_asymmetric,
                    asymmetric_to_optional: _asymmetric_to_optional,
                    asymmetric_to_nonexistent: _asymmetric_to_nonexistent,
                    optional_to_required: _optional_to_required,
                    optional_to_asymmetric: _optional_to_asymmetric,
                    optional_to_optional: _optional_to_optional,
                    optional_to_nonexistent: _optional_to_nonexistent,
                })
            }
        }

        impl From<ExampleStructOut> for ExampleStructIn {
            fn from(message: ExampleStructOut) -> Self {
                ExampleStructIn {
                    required_to_required: message.required_to_required.into(),
                    required_to_asymmetric: message.required_to_asymmetric.into(),
                    required_to_optional: message.required_to_optional.into(),
                    required_to_nonexistent: message.required_to_nonexistent.into(),
                    asymmetric_to_required: Some(message.asymmetric_to_required.into()),
                    asymmetric_to_asymmetric: Some(message.asymmetric_to_asymmetric.into()),
                    asymmetric_to_optional: Some(message.asymmetric_to_optional.into()),
                    asymmetric_to_nonexistent: Some(message.asymmetric_to_nonexistent.into()),
                    optional_to_required: message.optional_to_required.map(|payload| payload.into()),
                    optional_to_asymmetric: message.optional_to_asymmetric.map(|payload| payload.into()),
                    optional_to_optional: message.optional_to_optional.map(|payload| payload.into()),
                    optional_to_nonexistent: message.optional_to_nonexistent.map(|payload| payload.into()),
                }
            }
        }

        impl ExampleStructOut {
            pub fn atlas(&self) -> ExampleStructAtlas {
                let _required_to_required = { let payload = &self.required_to_required; (payload.len()) };
                let _required_to_asymmetric = { let payload = &self.required_to_asymmetric; (payload.len()) };
                let _required_to_optional = { let payload = &self.required_to_optional; (payload.len()) };
                let _required_to_nonexistent = { let payload = &self.required_to_nonexistent; (payload.len()) };
                let _asymmetric_to_required = { let payload = &self.asymmetric_to_required; (payload.len()) };
                let _asymmetric_to_asymmetric = { let payload = &self.asymmetric_to_asymmetric; (payload.len()) };
                let _asymmetric_to_optional = { let payload = &self.asymmetric_to_optional; (payload.len()) };
                let _asymmetric_to_nonexistent = { let payload = &self.asymmetric_to_nonexistent; (payload.len()) };
                let _optional_to_required = self.optional_to_required.as_ref().map(|payload| (payload.len()));
                let _optional_to_asymmetric = self.optional_to_asymmetric.as_ref().map(|payload| (payload.len()));
                let _optional_to_optional = self.optional_to_optional.as_ref().map(|payload| (payload.len()));
                let _optional_to_nonexistent = self.optional_to_nonexistent.as_ref().map(|payload| (payload.len()));

                ExampleStructAtlas {
                    _size:
                        { let payload_atlas = &_required_to_required; let payload_size = *payload_atlas; super::super::field_header_size(0_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_required_to_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(1_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_required_to_optional; let payload_size = *payload_atlas; super::super::field_header_size(2_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_required_to_nonexistent; let payload_size = *payload_atlas; super::super::field_header_size(3_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_asymmetric_to_required; let payload_size = *payload_atlas; super::super::field_header_size(4_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_asymmetric_to_asymmetric; let payload_size = *payload_atlas; super::super::field_header_size(5_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_asymmetric_to_optional; let payload_size = *payload_atlas; super::super::field_header_size(6_u64, payload_size, false) + payload_size }
                        + { let payload_atlas = &_asymmetric_to_nonexistent; let payload_size = *payload_atlas; super::super::field_header_size(7_u64, payload_size, false) + payload_size }
                        + _optional_to_required.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(8_u64, payload_size, false) + payload_size })
                        + _optional_to_asymmetric.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(9_u64, payload_size, false) + payload_size })
                        + _optional_to_optional.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(10_u64, payload_size, false) + payload_size })
                        + _optional_to_nonexistent.as_ref().map_or(0_usize, |payload_atlas| { let payload_size = *payload_atlas; super::super::field_header_size(11_u64, payload_size, false) + payload_size }),
                    required_to_required: _required_to_required,
                    required_to_asymmetric: _required_to_asymmetric,
                    required_to_optional: _required_to_optional,
                    required_to_nonexistent: _required_to_nonexistent,
                    asymmetric_to_required: _asymmetric_to_required,
                    asymmetric_to_asymmetric: _asymmetric_to_asymmetric,
                    asymmetric_to_optional: _asymmetric_to_optional,
                    asymmetric_to_nonexistent: _asymmetric_to_nonexistent,
                    optional_to_required: _optional_to_required,
                    optional_to_asymmetric: _optional_to_asymmetric,
                    optional_to_optional: _optional_to_optional,
                    optional_to_nonexistent: _optional_to_nonexistent,
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &ExampleStructAtlas,
            ) -> ::std::io::Result<()> {
                {
                    let payload = &self.required_to_required;
                    let payload_atlas = &atlas.required_to_required;
                    super::super::serialize_field_header(writer, 0_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.required_to_asymmetric;
                    let payload_atlas = &atlas.required_to_asymmetric;
                    super::super::serialize_field_header(writer, 1_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.required_to_optional;
                    let payload_atlas = &atlas.required_to_optional;
                    super::super::serialize_field_header(writer, 2_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.required_to_nonexistent;
                    let payload_atlas = &atlas.required_to_nonexistent;
                    super::super::serialize_field_header(writer, 3_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.asymmetric_to_required;
                    let payload_atlas = &atlas.asymmetric_to_required;
                    super::super::serialize_field_header(writer, 4_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.asymmetric_to_asymmetric;
                    let payload_atlas = &atlas.asymmetric_to_asymmetric;
                    super::super::serialize_field_header(writer, 5_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.asymmetric_to_optional;
                    let payload_atlas = &atlas.asymmetric_to_optional;
                    super::super::serialize_field_header(writer, 6_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                {
                    let payload = &self.asymmetric_to_nonexistent;
                    let payload_atlas = &atlas.asymmetric_to_nonexistent;
                    super::super::serialize_field_header(writer, 7_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.optional_to_required, &atlas.optional_to_required) {
                    super::super::serialize_field_header(writer, 8_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.optional_to_asymmetric, &atlas.optional_to_asymmetric) {
                    super::super::serialize_field_header(writer, 9_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.optional_to_optional, &atlas.optional_to_optional) {
                    super::super::serialize_field_header(writer, 10_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                if let (Some(payload), Some(payload_atlas)) = (&self.optional_to_nonexistent, &atlas.optional_to_nonexistent) {
                    super::super::serialize_field_header(writer, 11_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                Ok(())
            }
        }

        impl ExampleStructAtlas {
            pub fn size(&self) -> usize {
                self._size
            }
        }

        #[derive(Clone, Debug)]
        pub enum ExampleChoiceAtlas {
            RequiredToRequired(usize, usize),
            RequiredToAsymmetric(usize, usize),
            AsymmetricToRequired(usize, usize, Box<ExampleChoiceAtlas>),
            AsymmetricToAsymmetric(usize, usize, Box<ExampleChoiceAtlas>),
            AsymmetricToOptional(usize, usize, Box<ExampleChoiceAtlas>),
            AsymmetricToNonexistent(usize, usize, Box<ExampleChoiceAtlas>),
            OptionalToRequired(usize, usize, Box<ExampleChoiceAtlas>),
            OptionalToAsymmetric(usize, usize, Box<ExampleChoiceAtlas>),
            OptionalToOptional(usize, usize, Box<ExampleChoiceAtlas>),
            OptionalToNonexistent(usize, usize, Box<ExampleChoiceAtlas>),
        }

        #[derive(Clone, Debug)]
        pub enum ExampleChoiceOut {
            RequiredToRequired(String),
            RequiredToAsymmetric(String),
            AsymmetricToRequired(String, Box<ExampleChoiceOut>),
            AsymmetricToAsymmetric(String, Box<ExampleChoiceOut>),
            AsymmetricToOptional(String, Box<ExampleChoiceOut>),
            AsymmetricToNonexistent(String, Box<ExampleChoiceOut>),
            OptionalToRequired(String, Box<ExampleChoiceOut>),
            OptionalToAsymmetric(String, Box<ExampleChoiceOut>),
            OptionalToOptional(String, Box<ExampleChoiceOut>),
            OptionalToNonexistent(String, Box<ExampleChoiceOut>),
        }

        #[derive(Clone, Debug)]
        pub enum ExampleChoiceIn {
            RequiredToRequired(String),
            RequiredToAsymmetric(String),
            AsymmetricToRequired(String),
            AsymmetricToAsymmetric(String),
            AsymmetricToOptional(String),
            AsymmetricToNonexistent(String),
            OptionalToRequired(String, Box<ExampleChoiceIn>),
            OptionalToAsymmetric(String, Box<ExampleChoiceIn>),
            OptionalToOptional(String, Box<ExampleChoiceIn>),
            OptionalToNonexistent(String, Box<ExampleChoiceIn>),
        }

        impl super::super::Serialize for ExampleChoiceOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for ExampleChoiceIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                loop {
                    let (index, payload_size) = super::super::deserialize_field_header(&mut *reader)?;

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        0 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::RequiredToRequired(payload));
                        }
                        1 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::RequiredToAsymmetric(payload));
                        }
                        4 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::AsymmetricToRequired(payload));
                        }
                        5 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::AsymmetricToAsymmetric(payload));
                        }
                        6 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::AsymmetricToOptional(payload));
                        }
                        7 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(ExampleChoiceIn::AsymmetricToNonexistent(payload));
                        }
                        8 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            let fallback = Box::new(<ExampleChoiceIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(ExampleChoiceIn::OptionalToRequired(payload, fallback));
                        }
                        9 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            let fallback = Box::new(<ExampleChoiceIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(ExampleChoiceIn::OptionalToAsymmetric(payload, fallback));
                        }
                        10 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            let fallback = Box::new(<ExampleChoiceIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(ExampleChoiceIn::OptionalToOptional(payload, fallback));
                        }
                        11 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            let fallback = Box::new(<ExampleChoiceIn as super::super::Deserialize>::deserialize(&mut *reader)?);
                            return Ok(ExampleChoiceIn::OptionalToNonexistent(payload, fallback));
                        }
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }
            }
        }

        impl From<ExampleChoiceOut> for ExampleChoiceIn {
            fn from(message: ExampleChoiceOut) -> Self {
                match message {
                    ExampleChoiceOut::RequiredToRequired(payload) => ExampleChoiceIn::RequiredToRequired(payload.into()),
                    ExampleChoiceOut::RequiredToAsymmetric(payload) => ExampleChoiceIn::RequiredToAsymmetric(payload.into()),
                    ExampleChoiceOut::AsymmetricToRequired(payload, fallback) => ExampleChoiceIn::AsymmetricToRequired(payload.into()),
                    ExampleChoiceOut::AsymmetricToAsymmetric(payload, fallback) => ExampleChoiceIn::AsymmetricToAsymmetric(payload.into()),
                    ExampleChoiceOut::AsymmetricToOptional(payload, fallback) => ExampleChoiceIn::AsymmetricToOptional(payload.into()),
                    ExampleChoiceOut::AsymmetricToNonexistent(payload, fallback) => ExampleChoiceIn::AsymmetricToNonexistent(payload.into()),
                    ExampleChoiceOut::OptionalToRequired(payload, fallback) => ExampleChoiceIn::OptionalToRequired(payload.into(), Box::new((*fallback).into())),
                    ExampleChoiceOut::OptionalToAsymmetric(payload, fallback) => ExampleChoiceIn::OptionalToAsymmetric(payload.into(), Box::new((*fallback).into())),
                    ExampleChoiceOut::OptionalToOptional(payload, fallback) => ExampleChoiceIn::OptionalToOptional(payload.into(), Box::new((*fallback).into())),
                    ExampleChoiceOut::OptionalToNonexistent(payload, fallback) => ExampleChoiceIn::OptionalToNonexistent(payload.into(), Box::new((*fallback).into())),
                }
            }
        }

        impl ExampleChoiceOut {
            pub fn atlas(&self) -> ExampleChoiceAtlas {
                match *self {
                    ExampleChoiceOut::RequiredToRequired(ref payload) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        ExampleChoiceAtlas::RequiredToRequired(super::super::field_header_size(0_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    ExampleChoiceOut::RequiredToAsymmetric(ref payload) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        ExampleChoiceAtlas::RequiredToAsymmetric(super::super::field_header_size(1_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                    ExampleChoiceOut::AsymmetricToRequired(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::AsymmetricToRequired(super::super::field_header_size(4_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::AsymmetricToAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::AsymmetricToAsymmetric(super::super::field_header_size(5_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::AsymmetricToOptional(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::AsymmetricToOptional(super::super::field_header_size(6_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::AsymmetricToNonexistent(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::AsymmetricToNonexistent(super::super::field_header_size(7_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::OptionalToRequired(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::OptionalToRequired(super::super::field_header_size(8_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::OptionalToAsymmetric(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::OptionalToAsymmetric(super::super::field_header_size(9_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::OptionalToOptional(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::OptionalToOptional(super::super::field_header_size(10_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                    ExampleChoiceOut::OptionalToNonexistent(ref payload, ref fallback) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        let fallback_atlas = fallback.atlas();
                        ExampleChoiceAtlas::OptionalToNonexistent(super::super::field_header_size(11_u64, payload_size, false) + payload_size + fallback_atlas.size(), payload_atlas, Box::new(fallback_atlas))
                    }
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &ExampleChoiceAtlas,
            ) -> ::std::io::Result<()> {
                match (self, atlas) {
                    (ExampleChoiceOut::RequiredToRequired(payload), ExampleChoiceAtlas::RequiredToRequired(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 0_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        Ok(())
                    }
                    (ExampleChoiceOut::RequiredToAsymmetric(payload), ExampleChoiceAtlas::RequiredToAsymmetric(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 1_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        Ok(())
                    }
                    (ExampleChoiceOut::AsymmetricToRequired(payload, fallback), ExampleChoiceAtlas::AsymmetricToRequired(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 4_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::AsymmetricToAsymmetric(payload, fallback), ExampleChoiceAtlas::AsymmetricToAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 5_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::AsymmetricToOptional(payload, fallback), ExampleChoiceAtlas::AsymmetricToOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 6_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::AsymmetricToNonexistent(payload, fallback), ExampleChoiceAtlas::AsymmetricToNonexistent(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 7_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::OptionalToRequired(payload, fallback), ExampleChoiceAtlas::OptionalToRequired(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 8_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::OptionalToAsymmetric(payload, fallback), ExampleChoiceAtlas::OptionalToAsymmetric(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 9_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::OptionalToOptional(payload, fallback), ExampleChoiceAtlas::OptionalToOptional(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 10_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (ExampleChoiceOut::OptionalToNonexistent(payload, fallback), ExampleChoiceAtlas::OptionalToNonexistent(_, payload_atlas, fallback_atlas)) => {
                        super::super::serialize_field_header(writer, 11_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        fallback.serialize_with_atlas(writer, fallback_atlas)
                    }
                    (_, _) => panic!(),
                }
            }
        }

        impl ExampleChoiceAtlas {
            pub fn size(&self) -> usize {
                match *self {
                    ExampleChoiceAtlas::RequiredToRequired(ref size, _) => *size,
                    ExampleChoiceAtlas::RequiredToAsymmetric(ref size, _) => *size,
                    ExampleChoiceAtlas::AsymmetricToRequired(ref size, _, _) => *size,
                    ExampleChoiceAtlas::AsymmetricToAsymmetric(ref size, _, _) => *size,
                    ExampleChoiceAtlas::AsymmetricToOptional(ref size, _, _) => *size,
                    ExampleChoiceAtlas::AsymmetricToNonexistent(ref size, _, _) => *size,
                    ExampleChoiceAtlas::OptionalToRequired(ref size, _, _) => *size,
                    ExampleChoiceAtlas::OptionalToAsymmetric(ref size, _, _) => *size,
                    ExampleChoiceAtlas::OptionalToOptional(ref size, _, _) => *size,
                    ExampleChoiceAtlas::OptionalToNonexistent(ref size, _, _) => *size,
                }
            }
        }
    }

    pub mod types {
        #[derive(Clone, Debug)]
        pub struct SingletonStructAtlas {
            pub _size: usize,
            pub x: usize,
        }

        #[derive(Clone, Debug)]
        pub struct SingletonStructOut {
            pub x: String,
        }

        #[derive(Clone, Debug)]
        pub struct SingletonStructIn {
            pub x: String,
        }

        impl super::super::Serialize for SingletonStructOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for SingletonStructIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                let mut _x: Option<String> = None;

                loop {
                    let (index, payload_size) = match super::super::deserialize_field_header(&mut *reader) {
                        Ok(header) => header,
                        Err(err) => {
                            if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                break;
                            }

                            return Err(err);
                        }
                    };

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        0 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            _x.get_or_insert(payload);
                        }
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }

                if _x.is_none() {
                    return Err(::std::io::Error::new(
                        ::std::io::ErrorKind::InvalidData,
                        super::super::MISSING_FIELDS_ERROR_MESSAGE,
                    ));
                }

                Ok(SingletonStructIn {
                    x: _x.unwrap(),
                })
            }
        }

        impl From<SingletonStructOut> for SingletonStructIn {
            fn from(message: SingletonStructOut) -> Self {
                SingletonStructIn {
                    x: message.x.into(),
                }
            }
        }

        impl SingletonStructOut {
            pub fn atlas(&self) -> SingletonStructAtlas {
                let _x = { let payload = &self.x; (payload.len()) };

                SingletonStructAtlas {
                    _size:
                        { let payload_atlas = &_x; let payload_size = *payload_atlas; super::super::field_header_size(0_u64, payload_size, false) + payload_size },
                    x: _x,
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &SingletonStructAtlas,
            ) -> ::std::io::Result<()> {
                {
                    let payload = &self.x;
                    let payload_atlas = &atlas.x;
                    super::super::serialize_field_header(writer, 0_u64, *payload_atlas, false)?;
                    writer.write_all(payload.as_bytes())?;
                }

                Ok(())
            }
        }

        impl SingletonStructAtlas {
            pub fn size(&self) -> usize {
                self._size
            }
        }

        #[derive(Clone, Debug)]
        pub enum SingletonChoiceAtlas {
            X(usize, usize),
        }

        #[derive(Clone, Debug)]
        pub enum SingletonChoiceOut {
            X(String),
        }

        #[derive(Clone, Debug)]
        pub enum SingletonChoiceIn {
            X(String),
        }

        impl super::super::Serialize for SingletonChoiceOut {
            fn size(&self) -> usize {
                self.atlas().size()
            }

            fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> ::std::io::Result<()> {
                let atlas = self.atlas();
                self.serialize_with_atlas(writer, &atlas)
            }
        }

        impl super::super::Deserialize for SingletonChoiceIn {
            fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>
            where
                Self: Sized,
                T: ::std::io::BufRead,
            {
                loop {
                    let (index, payload_size) = super::super::deserialize_field_header(&mut *reader)?;

                    let mut sub_reader = ::std::io::Read::take(&mut *reader, payload_size as u64);

                    match index {
                        0 => {
                            let mut buffer = vec![];
                            ::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;
                            let payload = std::str::from_utf8(&buffer).map_or_else(
                                |err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),
                                |result| Ok(result.to_owned()),
                            )?;
                            super::super::finish(&mut *reader)?;
                            return Ok(SingletonChoiceIn::X(payload));
                        }
                        _ => {
                            super::super::skip(&mut sub_reader, payload_size as usize)?;
                        }
                    }
                }
            }
        }

        impl From<SingletonChoiceOut> for SingletonChoiceIn {
            fn from(message: SingletonChoiceOut) -> Self {
                match message {
                    SingletonChoiceOut::X(payload) => SingletonChoiceIn::X(payload.into()),
                }
            }
        }

        impl SingletonChoiceOut {
            pub fn atlas(&self) -> SingletonChoiceAtlas {
                match *self {
                    SingletonChoiceOut::X(ref payload) => {
                        let payload_atlas = (payload.len());
                        let payload_size = { let payload_atlas = &payload_atlas; *payload_atlas };
                        SingletonChoiceAtlas::X(super::super::field_header_size(0_u64, payload_size, false) + payload_size, payload_atlas)
                    }
                }
            }

            pub fn serialize_with_atlas<T: ::std::io::Write>(
                &self,
                writer: &mut T,
                atlas: &SingletonChoiceAtlas,
            ) -> ::std::io::Result<()> {
                match (self, atlas) {
                    (SingletonChoiceOut::X(payload), SingletonChoiceAtlas::X(_, payload_atlas)) => {
                        super::super::serialize_field_header(writer, 0_u64, *payload_atlas, false)?;
                        writer.write_all(payload.as_bytes())?;
                        Ok(())
                    }
                    (_, _) => panic!(),
                }
            }
        }

        impl SingletonChoiceAtlas {
            pub fn size(&self) -> usize {
                match *self {
                    SingletonChoiceAtlas::X(ref size, _) => *size,
                }
            }
        }
    }
}

pub mod types {
}
