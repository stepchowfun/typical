// This file was automatically generated by Typical 0.0.0.
// Visit https://github.com/stepchowfun/typical for more information.

/* eslint-disable */

export function unreachable(x: never): never {
  return x;
}

function zigzagEncode(value: bigint): bigint {
  const twice = value << 1n;
  return value < 0n ? -1n - twice : twice;
}

function zigzagDecode(value: bigint): bigint {
  const half = (value + 1n) >> 1n;
  return (value & 1n) === 0n ? half : -half;
}

function varintSizeFromValue(value: bigint): number {
  if (value < 128n) {
    return 1;
  }

  if (value < 16_512n) {
    return 2;
  }

  if (value < 2_113_664n) {
    return 3;
  }

  if (value < 270_549_120n) {
    return 4;
  }

  if (value < 34_630_287_488n) {
    return 5;
  }

  if (value < 4_432_676_798_592n) {
    return 6;
  }

  if (value < 567_382_630_219_904n) {
    return 7;
  }

  if (value < 72_624_976_668_147_840n) {
    return 8;
  }

  return 9;
}

function varintSizeFromFirstByte(firstByte: number): number {
  let trailingZeros = 0;

  while (trailingZeros < 8 && (firstByte & 1) !== 1) {
    trailingZeros += 1;
    firstByte >>= 1;
  }

  return trailingZeros + 1;
}

const dataView64 = new DataView(new ArrayBuffer(8));

function serializeVarint(
  dataView: DataView,
  offset: number,
  value: bigint,
): number {
  if (value < 128n) {
    dataView.setUint8(offset, Number(value << 1n) | 0b0000_0001);
    return offset + 1;
  }

  if (value < 16_512n) {
    value -= 128n;
    dataView.setUint8(offset, Number((value << 2n) % 256n) | 0b0000_0010);
    dataView.setUint8(offset + 1, Number(value >> 6n));
    return offset + 2;
  }

  if (value < 2_113_664n) {
    value -= 16_512n;
    dataView.setUint8(offset, Number((value << 3n) % 256n) | 0b0000_0100);
    dataView.setUint16(offset + 1, Number((value >> 5n) % 65_536n), true);
    return offset + 3;
  }

  if (value < 270_549_120n) {
    value -= 2_113_664n;
    dataView.setUint8(offset, Number((value << 4n) % 256n) | 0b0000_1000);
    dataView.setUint8(offset + 1, Number((value >> 4n) % 256n));
    dataView.setUint16(offset + 2, Number((value >> 12n) % 65_536n), true);
    return offset + 4;
  }

  if (value < 34_630_287_488n) {
    value -= 270_549_120n;
    dataView.setUint8(offset, Number((value << 5n) % 256n) | 0b0001_0000);
    dataView.setUint32(
      offset + 1,
      Number((value >> 3n) % 4_294_967_296n),
      true,
    );
    return offset + 5;
  }

  if (value < 4_432_676_798_592n) {
    value -= 34_630_287_488n;
    dataView.setUint8(offset, Number((value << 6n) % 256n) | 0b0010_0000);
    dataView.setUint8(offset + 1, Number((value >> 2n) % 256n));
    dataView.setUint32(
      offset + 2,
      Number((value >> 10n) % 4_294_967_296n),
      true,
    );
    return offset + 6;
  }

  if (value < 567_382_630_219_904n) {
    value -= 4_432_676_798_592n;
    dataView.setUint8(offset, Number((value << 7n) % 256n) | 0b0100_0000);
    dataView.setUint16(offset + 1, Number((value >> 1n) % 65_536n), true);
    dataView.setUint32(
      offset + 3,
      Number((value >> 17n) % 4_294_967_296n),
      true,
    );
    return offset + 7;
  }

  if (value < 72_624_976_668_147_840n) {
    value -= 567_382_630_219_904n;
    dataView.setUint8(offset, 0b1000_0000);
    dataView.setUint8(offset + 1, Number(value % 256n));
    dataView.setUint16(offset + 2, Number((value >> 8n) % 65_536n), true);
    dataView.setUint32(
      offset + 4,
      Number((value >> 24n) % 4_294_967_296n),
      true,
    );
    return offset + 8;
  }

  value -= 72_624_976_668_147_840n;
  dataView.setUint8(offset, 0b0000_0000);
  dataView.setBigUint64(offset + 1, value, true);
  return offset + 9;
}

function deserializeVarint(
  dataView: DataView,
  offset: number,
): [number, bigint] {
  const firstByte = dataView.getUint8(offset);
  const sizeMinusOne = varintSizeFromFirstByte(firstByte) - 1;

  const offsetPlusOne = offset + 1;
  dataView64.setBigUint64(0, 0n, true);
  for (let i = 0; i < sizeMinusOne; i += 1) {
    dataView64.setUint8(i, dataView.getUint8(offsetPlusOne + i));
  }
  const remainingBytesValue = dataView64.getBigUint64(0, true);

  switch (sizeMinusOne) {
    case 0:
      return [offset + 1, BigInt(firstByte >> 1)];
    case 1:
      return [
        offset + 2,
        128n + BigInt(firstByte >> 2) + (remainingBytesValue << 6n),
      ];
    case 2:
      return [
        offset + 3,
        16_512n + BigInt(firstByte >> 3) + (remainingBytesValue << 5n),
      ];
    case 3:
      return [
        offset + 4,
        2_113_664n + BigInt(firstByte >> 4) + (remainingBytesValue << 4n),
      ];
    case 4:
      return [
        offset + 5,
        270_549_120n + BigInt(firstByte >> 5) + (remainingBytesValue << 3n),
      ];
    case 5:
      return [
        offset + 6,
        34_630_287_488n + BigInt(firstByte >> 6) + (remainingBytesValue << 2n),
      ];
    case 6:
      return [
        offset + 7,
        4_432_676_798_592n +
          BigInt(firstByte >> 7) +
          (remainingBytesValue << 1n),
      ];
    case 7:
      return [offset + 8, 567_382_630_219_904n + remainingBytesValue];
    default:
      return [
        offset + 9,
        (72_624_976_668_147_840n + remainingBytesValue) %
          18_446_744_073_709_551_616n,
      ];
  }
}

function fieldHeaderSize(
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {
  switch (payloadSize) {
    case 0:
      return varintSizeFromValue(index << 2n);
    case 8:
      return varintSizeFromValue((index << 2n) | 1n);
    default:
      if (integerEncoded) {
        return varintSizeFromValue((index << 2n) | 2n);
      }

      return (
        varintSizeFromValue((index << 2n) | 3n) +
        varintSizeFromValue(BigInt(payloadSize))
      );
  }
}

function serializeFieldHeader(
  dataView: DataView,
  offset: number,
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {
  switch (payloadSize) {
    case 0:
      return serializeVarint(dataView, offset, index << 2n);
    case 8:
      return serializeVarint(dataView, offset, (index << 2n) | 1n);
    default:
      if (integerEncoded) {
        return serializeVarint(dataView, offset, (index << 2n) | 2n);
      }

      offset = serializeVarint(dataView, offset, (index << 2n) | 3n);

      return serializeVarint(dataView, offset, BigInt(payloadSize));
  }
}

function deserializeFieldHeader(
  dataView: DataView,
  offset: number,
): [number, bigint, number] {
  const [newOffset, tag] = deserializeVarint(dataView, offset);

  const index = tag >> 2n;

  switch (tag & 3n) {
    case 0n:
      return [newOffset, index, 0];
    case 1n:
      return [newOffset, index, 8];
    case 2n:
      return [newOffset, index, varintSizeFromFirstByte(dataView.getUint8(newOffset))];
    default: {
      const [newNewOffset, sizeValue] = deserializeVarint(dataView, newOffset);
      return [newNewOffset, index, Number(sizeValue)];
    }
  }
}

const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

export namespace CircularDependency {
  export namespace Dependency {
    export namespace Types {
      export type StructFromBelowOut = {
        x: CircularDependency.Types.StructFromAboveOut;
      };

      export type StructFromBelowIn = {
        x: CircularDependency.Types.StructFromAboveIn;
      };

      export namespace StructFromBelow {
        export function size(value: StructFromBelowOut): number {
          let valueSize = 0;
          let payloadSize = 0;

          {
            const payload = value.x;
            payloadSize = CircularDependency.Types.StructFromAbove.size(payload);
            valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }

          return valueSize;
        }

        export function serialize(
          dataView: DataView,
          offset: number,
          value: StructFromBelowOut,
        ): number {
          let payloadSize = 0;

          {
            const payload = value.x;
            payloadSize = CircularDependency.Types.StructFromAbove.size(payload);
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            offset = CircularDependency.Types.StructFromAbove.serialize(dataView, offset, payload);
          }

          return offset;
        }

        export function deserialize(dataView: DataView): StructFromBelowIn {
          const dataViewAlias = dataView;

          let offset = 0;

          let $x;

          while (true) {
            let index, payloadSize;
            try {
              [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
            } catch (e) {
              if (e instanceof RangeError) {
                break;
              } else {
                throw e;
              }
            }
            switch (index) {
              case 0n: {
                const dataView = new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  payloadSize,
                );
                const oldOffset = offset;
                offset = 0;
                let payload = CircularDependency.Types.StructFromAbove.deserialize(dataView);
                offset = dataView.byteLength;
                offset += oldOffset;
                $x = payload;
                break;
              }
              default:
                offset += payloadSize;
                break;
            }
          }

          if ($x === undefined) {
            throw new Error('Struct missing one or more field(s).');
          }

          return {
            x: $x,
          };
        }

        export function outToIn(value: StructFromBelowOut): StructFromBelowIn {
          return value;
        }
      }
    }
  }

  export namespace Types {
    export type StructFromAboveOut = {
    };

    export type StructFromAboveIn = {
    };

    export namespace StructFromAbove {
      export function size(value: StructFromAboveOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: StructFromAboveOut,
      ): number {
        let payloadSize = 0;

        return offset;
      }

      export function deserialize(dataView: DataView): StructFromAboveIn {
        return {
        };
      }

      export function outToIn(value: StructFromAboveOut): StructFromAboveIn {
        return value;
      }
    }
  }
}

export namespace Comprehensive {
  export namespace Types {
    export type LocalStructOut = {
    };

    export type LocalStructIn = {
    };

    export namespace LocalStruct {
      export function size(value: LocalStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: LocalStructOut,
      ): number {
        let payloadSize = 0;

        return offset;
      }

      export function deserialize(dataView: DataView): LocalStructIn {
        return {
        };
      }

      export function outToIn(value: LocalStructOut): LocalStructIn {
        return value;
      }
    }

    export type FooOut = {
      aRequired: null;
      bRequired: number;
      cRequired: bigint;
      dRequired: bigint;
      eRequired: boolean;
      fRequired: ArrayBuffer;
      gRequired: string;
      hRequired: Comprehensive.Types.LocalStructOut;
      iRequired: Degenerate.Types.EmptyStructOut;
      jRequired: null[];
      kRequired: number[];
      lRequired: bigint[];
      mRequired: bigint[];
      nRequired: boolean[];
      oRequired: ArrayBuffer[];
      pRequired: string[];
      qRequired: Comprehensive.Types.LocalStructOut[];
      rRequired: Degenerate.Types.EmptyStructOut[];
      sRequired: null[][];
      tRequired: number[][];
      uRequired: bigint[][];
      vRequired: bigint[][];
      wRequired: boolean[][];
      xRequired: ArrayBuffer[][];
      yRequired: string[][];
      zRequired: Comprehensive.Types.LocalStructOut[][];
      aaRequired: Degenerate.Types.EmptyStructOut[][];
      aAsymmetric: null;
      bAsymmetric: number;
      cAsymmetric: bigint;
      dAsymmetric: bigint;
      eAsymmetric: boolean;
      fAsymmetric: ArrayBuffer;
      gAsymmetric: string;
      hAsymmetric: Comprehensive.Types.LocalStructOut;
      iAsymmetric: Degenerate.Types.EmptyStructOut;
      jAsymmetric: null[];
      kAsymmetric: number[];
      lAsymmetric: bigint[];
      mAsymmetric: bigint[];
      nAsymmetric: boolean[];
      oAsymmetric: ArrayBuffer[];
      pAsymmetric: string[];
      qAsymmetric: Comprehensive.Types.LocalStructOut[];
      rAsymmetric: Degenerate.Types.EmptyStructOut[];
      sAsymmetric: null[][];
      tAsymmetric: number[][];
      uAsymmetric: bigint[][];
      vAsymmetric: bigint[][];
      wAsymmetric: boolean[][];
      xAsymmetric: ArrayBuffer[][];
      yAsymmetric: string[][];
      zAsymmetric: Comprehensive.Types.LocalStructOut[][];
      aaAsymmetric: Degenerate.Types.EmptyStructOut[][];
      aOptional?: null;
      bOptional?: number;
      cOptional?: bigint;
      dOptional?: bigint;
      eOptional?: boolean;
      fOptional?: ArrayBuffer;
      gOptional?: string;
      hOptional?: Comprehensive.Types.LocalStructOut;
      iOptional?: Degenerate.Types.EmptyStructOut;
      jOptional?: null[];
      kOptional?: number[];
      lOptional?: bigint[];
      mOptional?: bigint[];
      nOptional?: boolean[];
      oOptional?: ArrayBuffer[];
      pOptional?: string[];
      qOptional?: Comprehensive.Types.LocalStructOut[];
      rOptional?: Degenerate.Types.EmptyStructOut[];
      sOptional?: null[][];
      tOptional?: number[][];
      uOptional?: bigint[][];
      vOptional?: bigint[][];
      wOptional?: boolean[][];
      xOptional?: ArrayBuffer[][];
      yOptional?: string[][];
      zOptional?: Comprehensive.Types.LocalStructOut[][];
      aaOptional?: Degenerate.Types.EmptyStructOut[][];
    };

    export type FooIn = {
      aRequired: null;
      bRequired: number;
      cRequired: bigint;
      dRequired: bigint;
      eRequired: boolean;
      fRequired: ArrayBuffer;
      gRequired: string;
      hRequired: Comprehensive.Types.LocalStructIn;
      iRequired: Degenerate.Types.EmptyStructIn;
      jRequired: null[];
      kRequired: number[];
      lRequired: bigint[];
      mRequired: bigint[];
      nRequired: boolean[];
      oRequired: ArrayBuffer[];
      pRequired: string[];
      qRequired: Comprehensive.Types.LocalStructIn[];
      rRequired: Degenerate.Types.EmptyStructIn[];
      sRequired: null[][];
      tRequired: number[][];
      uRequired: bigint[][];
      vRequired: bigint[][];
      wRequired: boolean[][];
      xRequired: ArrayBuffer[][];
      yRequired: string[][];
      zRequired: Comprehensive.Types.LocalStructIn[][];
      aaRequired: Degenerate.Types.EmptyStructIn[][];
      aAsymmetric?: null;
      bAsymmetric?: number;
      cAsymmetric?: bigint;
      dAsymmetric?: bigint;
      eAsymmetric?: boolean;
      fAsymmetric?: ArrayBuffer;
      gAsymmetric?: string;
      hAsymmetric?: Comprehensive.Types.LocalStructIn;
      iAsymmetric?: Degenerate.Types.EmptyStructIn;
      jAsymmetric?: null[];
      kAsymmetric?: number[];
      lAsymmetric?: bigint[];
      mAsymmetric?: bigint[];
      nAsymmetric?: boolean[];
      oAsymmetric?: ArrayBuffer[];
      pAsymmetric?: string[];
      qAsymmetric?: Comprehensive.Types.LocalStructIn[];
      rAsymmetric?: Degenerate.Types.EmptyStructIn[];
      sAsymmetric?: null[][];
      tAsymmetric?: number[][];
      uAsymmetric?: bigint[][];
      vAsymmetric?: bigint[][];
      wAsymmetric?: boolean[][];
      xAsymmetric?: ArrayBuffer[][];
      yAsymmetric?: string[][];
      zAsymmetric?: Comprehensive.Types.LocalStructIn[][];
      aaAsymmetric?: Degenerate.Types.EmptyStructIn[][];
      aOptional?: null;
      bOptional?: number;
      cOptional?: bigint;
      dOptional?: bigint;
      eOptional?: boolean;
      fOptional?: ArrayBuffer;
      gOptional?: string;
      hOptional?: Comprehensive.Types.LocalStructIn;
      iOptional?: Degenerate.Types.EmptyStructIn;
      jOptional?: null[];
      kOptional?: number[];
      lOptional?: bigint[];
      mOptional?: bigint[];
      nOptional?: boolean[];
      oOptional?: ArrayBuffer[];
      pOptional?: string[];
      qOptional?: Comprehensive.Types.LocalStructIn[];
      rOptional?: Degenerate.Types.EmptyStructIn[];
      sOptional?: null[][];
      tOptional?: number[][];
      uOptional?: bigint[][];
      vOptional?: bigint[][];
      wOptional?: boolean[][];
      xOptional?: ArrayBuffer[][];
      yOptional?: string[][];
      zOptional?: Comprehensive.Types.LocalStructIn[][];
      aaOptional?: Degenerate.Types.EmptyStructIn[][];
    };

    export namespace Foo {
      export function size(value: FooOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.aRequired;
          payloadSize = 0;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.bRequired;
          if (Object.is(payload, 0)) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.cRequired;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(2n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.dRequired;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(3n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.eRequired;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(4n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.fRequired;
          payloadSize = payload.byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.gRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.hRequired;
          payloadSize = Comprehensive.Types.LocalStruct.size(payload);
          valueSize += fieldHeaderSize(7n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.iRequired;
          payloadSize = Degenerate.Types.EmptyStruct.size(payload);
          valueSize += fieldHeaderSize(8n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.jRequired;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.kRequired;
          payloadSize = 8 * payload.length;
          valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.lRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(11n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.mRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(12n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.oRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.pRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(15n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.qRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(16n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.rRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(17n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.sRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(18n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.tRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 8 * payload.length;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(19n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.uRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(20n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.vRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(21n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.wRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(22n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.xRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(23n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.yRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(24n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.zRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(25n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aaRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(26n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aAsymmetric;
          payloadSize = 0;
          valueSize += fieldHeaderSize(28n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.bAsymmetric;
          if (Object.is(payload, 0)) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(29n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.cAsymmetric;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(30n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.dAsymmetric;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(31n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.eAsymmetric;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(32n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.fAsymmetric;
          payloadSize = payload.byteLength;
          valueSize += fieldHeaderSize(33n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.gAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(34n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.hAsymmetric;
          payloadSize = Comprehensive.Types.LocalStruct.size(payload);
          valueSize += fieldHeaderSize(35n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.iAsymmetric;
          payloadSize = Degenerate.Types.EmptyStruct.size(payload);
          valueSize += fieldHeaderSize(36n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.jAsymmetric;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          valueSize += fieldHeaderSize(37n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.kAsymmetric;
          payloadSize = 8 * payload.length;
          valueSize += fieldHeaderSize(38n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.lAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(39n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.mAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(40n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(41n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.oAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(42n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.pAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(43n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.qAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(44n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.rAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(45n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.sAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(46n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.tAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 8 * payload.length;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(47n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.uAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(48n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.vAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(49n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.wAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(50n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.xAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(51n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.yAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(52n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.zAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(53n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aaAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(54n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = 0;
            valueSize += fieldHeaderSize(56n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.bOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            if (Object.is(payload, 0)) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            valueSize += fieldHeaderSize(57n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.cOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            valueSize += fieldHeaderSize(58n, payloadSize, true) + payloadSize;
          }
        }

        {
          const payload = value.dOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            valueSize += fieldHeaderSize(59n, payloadSize, true) + payloadSize;
          }
        }

        {
          const payload = value.eOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            valueSize += fieldHeaderSize(60n, payloadSize, true) + payloadSize;
          }
        }

        {
          const payload = value.fOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = payload.byteLength;
            valueSize += fieldHeaderSize(61n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.gOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
            valueSize += fieldHeaderSize(62n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.hOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            valueSize += fieldHeaderSize(63n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.iOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            valueSize += fieldHeaderSize(64n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.jOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            valueSize += fieldHeaderSize(65n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.kOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = 8 * payload.length;
            valueSize += fieldHeaderSize(66n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.lOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(67n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.mOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(68n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.nOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(69n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.oOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(70n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.pOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(71n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.qOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(72n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.rOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(73n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.sOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(74n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.tOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(75n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.uOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(76n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.vOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(77n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.wOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(78n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.xOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(79n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.yOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(80n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.zOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(81n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.aaOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            valueSize += fieldHeaderSize(82n, payloadSize, false) + payloadSize;
          }
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: FooOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.aRequired;
          payloadSize = 0;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
        }

        {
          const payload = value.bRequired;
          if (Object.is(payload, 0)) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          if (payloadSize !== 0) {
            dataView.setFloat64(offset, payload, true);
            offset += 8;
          }
        }

        {
          const payload = value.cRequired;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.dRequired;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.eRequired;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.fRequired;
          payloadSize = payload.byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const sourceBuffer = new Uint8Array(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.gRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.hRequired;
          payloadSize = Comprehensive.Types.LocalStruct.size(payload);
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
        }

        {
          const payload = value.iRequired;
          payloadSize = Degenerate.Types.EmptyStruct.size(payload);
          offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
          offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
        }

        {
          const payload = value.jRequired;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.kRequired;
          payloadSize = 8 * payload.length;
          offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = 8;
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
          }
        }

        {
          const payload = value.lRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = varintSizeFromValue(payload);
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.mRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.nRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = 1;
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.oRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = payload.byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const sourceBuffer = new Uint8Array(payload);
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(sourceBuffer, offset);
                offset += sourceBuffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.pRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 15n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = textEncoder.encode(payload).byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const sourceBuffer = textEncoder.encode(payload);
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(sourceBuffer, offset);
                offset += sourceBuffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.qRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 16n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
            }
          }
        }

        {
          const payload = value.rRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
            }
          }
        }

        {
          const payload = value.sRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const varint = BigInt(payload.length);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.tRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 8 * payload.length;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 19n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = 8 * payload.length;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = 8;
                  dataView.setFloat64(offset, payload, true);
                  offset += 8;
                }
              }
            }
          }
        }

        {
          const payload = value.uRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 20n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = varintSizeFromValue(payload);
                  {
                    const varint = payload;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.vRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 21n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  {
                    const varint = zigzagEncode(payload);
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.wRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 22n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = 1;
                  {
                    const varint = payload ? 1n : 0n;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.xRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 23n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = payload.byteLength;
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  {
                    const sourceBuffer = new Uint8Array(payload);
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(sourceBuffer, offset);
                    offset += sourceBuffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.yRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 24n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = textEncoder.encode(payload).byteLength;
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  {
                    const sourceBuffer = textEncoder.encode(payload);
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(sourceBuffer, offset);
                    offset += sourceBuffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.zRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 25n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                }
              }
            }
          }
        }

        {
          const payload = value.aaRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 26n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                }
              }
            }
          }
        }

        {
          const payload = value.aAsymmetric;
          payloadSize = 0;
          offset = serializeFieldHeader(dataView, offset, 28n, payloadSize, false);
        }

        {
          const payload = value.bAsymmetric;
          if (Object.is(payload, 0)) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 29n, payloadSize, false);
          if (payloadSize !== 0) {
            dataView.setFloat64(offset, payload, true);
            offset += 8;
          }
        }

        {
          const payload = value.cAsymmetric;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 30n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.dAsymmetric;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          offset = serializeFieldHeader(dataView, offset, 31n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.eAsymmetric;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          offset = serializeFieldHeader(dataView, offset, 32n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.fAsymmetric;
          payloadSize = payload.byteLength;
          offset = serializeFieldHeader(dataView, offset, 33n, payloadSize, false);
          {
            const sourceBuffer = new Uint8Array(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.gAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 34n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.hAsymmetric;
          payloadSize = Comprehensive.Types.LocalStruct.size(payload);
          offset = serializeFieldHeader(dataView, offset, 35n, payloadSize, false);
          offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
        }

        {
          const payload = value.iAsymmetric;
          payloadSize = Degenerate.Types.EmptyStruct.size(payload);
          offset = serializeFieldHeader(dataView, offset, 36n, payloadSize, false);
          offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
        }

        {
          const payload = value.jAsymmetric;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          offset = serializeFieldHeader(dataView, offset, 37n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.kAsymmetric;
          payloadSize = 8 * payload.length;
          offset = serializeFieldHeader(dataView, offset, 38n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = 8;
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
          }
        }

        {
          const payload = value.lAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 39n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = varintSizeFromValue(payload);
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.mAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 40n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.nAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 41n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = 1;
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.oAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 42n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = payload.byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const sourceBuffer = new Uint8Array(payload);
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(sourceBuffer, offset);
                offset += sourceBuffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.pAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 43n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = textEncoder.encode(payload).byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const sourceBuffer = textEncoder.encode(payload);
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(sourceBuffer, offset);
                offset += sourceBuffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.qAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 44n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
            }
          }
        }

        {
          const payload = value.rAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 45n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
            }
          }
        }

        {
          const payload = value.sAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 46n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const varint = BigInt(payload.length);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.tAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 8 * payload.length;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 47n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              payloadSize = 8 * payload.length;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = 8;
                  dataView.setFloat64(offset, payload, true);
                  offset += 8;
                }
              }
            }
          }
        }

        {
          const payload = value.uAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 48n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = varintSizeFromValue(payload);
                  {
                    const varint = payload;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.vAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 49n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  {
                    const varint = zigzagEncode(payload);
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.wAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 50n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = 1;
                  {
                    const varint = payload ? 1n : 0n;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.xAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 51n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = payload.byteLength;
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  {
                    const sourceBuffer = new Uint8Array(payload);
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(sourceBuffer, offset);
                    offset += sourceBuffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.yAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 52n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = textEncoder.encode(payload).byteLength;
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  {
                    const sourceBuffer = textEncoder.encode(payload);
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(sourceBuffer, offset);
                    offset += sourceBuffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.zAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 53n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                }
              }
            }
          }
        }

        {
          const payload = value.aaAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 54n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                }
              }
            }
          }
        }

        {
          const payload = value.aOptional;
          if (payload !== undefined) {
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 56n, payloadSize, false);
          }
        }

        {
          const payload = value.bOptional;
          if (payload !== undefined) {
            if (Object.is(payload, 0)) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 57n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
          }
        }

        {
          const payload = value.cOptional;
          if (payload !== undefined) {
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 58n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.dOptional;
          if (payload !== undefined) {
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 59n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.eOptional;
          if (payload !== undefined) {
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 60n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.fOptional;
          if (payload !== undefined) {
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 61n, payloadSize, false);
            {
              const sourceBuffer = new Uint8Array(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
          }
        }

        {
          const payload = value.gOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 62n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
          }
        }

        {
          const payload = value.hOptional;
          if (payload !== undefined) {
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 63n, payloadSize, false);
            offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
          }
        }

        {
          const payload = value.iOptional;
          if (payload !== undefined) {
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 64n, payloadSize, false);
            offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
          }
        }

        {
          const payload = value.jOptional;
          if (payload !== undefined) {
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 65n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.kOptional;
          if (payload !== undefined) {
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 66n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
                offset += 8;
              }
            }
          }
        }

        {
          const payload = value.lOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 67n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.mOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 68n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.nOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 69n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.oOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 70n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const sourceBuffer = new Uint8Array(payload);
                  const targetBuffer = new Uint8Array(
                    dataView.buffer,
                    dataView.byteOffset,
                    dataView.byteLength,
                  );
                  targetBuffer.set(sourceBuffer, offset);
                  offset += sourceBuffer.byteLength;
                }
              }
            }
          }
        }

        {
          const payload = value.pOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 71n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const sourceBuffer = textEncoder.encode(payload);
                  const targetBuffer = new Uint8Array(
                    dataView.buffer,
                    dataView.byteOffset,
                    dataView.byteLength,
                  );
                  targetBuffer.set(sourceBuffer, offset);
                  offset += sourceBuffer.byteLength;
                }
              }
            }
          }
        }

        {
          const payload = value.qOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 72n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
              }
            }
          }
        }

        {
          const payload = value.rOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 73n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
              }
            }
          }
        }

        {
          const payload = value.sOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 74n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const varint = BigInt(payload.length);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.tOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 75n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 8 * payload.length;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = 8;
                    dataView.setFloat64(offset, payload, true);
                    offset += 8;
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.uOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 76n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = varintSizeFromValue(payload);
                    {
                      const varint = payload;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.vOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 77n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    {
                      const varint = zigzagEncode(payload);
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.wOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 78n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = 1;
                    {
                      const varint = payload ? 1n : 0n;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.xOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 79n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = payload.byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const sourceBuffer = new Uint8Array(payload);
                      const targetBuffer = new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset,
                        dataView.byteLength,
                      );
                      targetBuffer.set(sourceBuffer, offset);
                      offset += sourceBuffer.byteLength;
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.yOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 80n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const sourceBuffer = textEncoder.encode(payload);
                      const targetBuffer = new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset,
                        dataView.byteLength,
                      );
                      targetBuffer.set(sourceBuffer, offset);
                      offset += sourceBuffer.byteLength;
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.zOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 81n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.aaOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 82n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
          }
        }

        return offset;
      }

      export function deserialize(dataView: DataView): FooIn {
        const dataViewAlias = dataView;

        let offset = 0;

        let $aRequired, $bRequired, $cRequired, $dRequired, $eRequired, $fRequired, $gRequired, $hRequired, $iRequired, $jRequired, $kRequired, $lRequired, $mRequired, $nRequired, $oRequired, $pRequired, $qRequired, $rRequired, $sRequired, $tRequired, $uRequired, $vRequired, $wRequired, $xRequired, $yRequired, $zRequired, $aaRequired, $aAsymmetric, $bAsymmetric, $cAsymmetric, $dAsymmetric, $eAsymmetric, $fAsymmetric, $gAsymmetric, $hAsymmetric, $iAsymmetric, $jAsymmetric, $kAsymmetric, $lAsymmetric, $mAsymmetric, $nAsymmetric, $oAsymmetric, $pAsymmetric, $qAsymmetric, $rAsymmetric, $sAsymmetric, $tAsymmetric, $uAsymmetric, $vAsymmetric, $wAsymmetric, $xAsymmetric, $yAsymmetric, $zAsymmetric, $aaAsymmetric, $aOptional, $bOptional, $cOptional, $dOptional, $eOptional, $fOptional, $gOptional, $hOptional, $iOptional, $jOptional, $kOptional, $lOptional, $mOptional, $nOptional, $oOptional, $pOptional, $qOptional, $rOptional, $sOptional, $tOptional, $uOptional, $vOptional, $wOptional, $xOptional, $yOptional, $zOptional, $aaOptional;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              $aRequired = payload;
              break;
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              offset += oldOffset;
              $bRequired = payload;
              break;
            }
            case 2n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              offset += oldOffset;
              $cRequired = payload;
              break;
            }
            case 3n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              offset += oldOffset;
              $dRequired = payload;
              break;
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $eRequired = payload;
              break;
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $fRequired = payload;
              break;
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $gRequired = payload;
              break;
            }
            case 7n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $hRequired = payload;
              break;
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $iRequired = payload;
              break;
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $jRequired = payload;
              break;
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $kRequired = payload;
              break;
            }
            case 11n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $lRequired = payload;
              break;
            }
            case 12n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $mRequired = payload;
              break;
            }
            case 13n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $nRequired = payload;
              break;
            }
            case 14n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $oRequired = payload;
              break;
            }
            case 15n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $pRequired = payload;
              break;
            }
            case 16n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $qRequired = payload;
              break;
            }
            case 17n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $rRequired = payload;
              break;
            }
            case 18n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $sRequired = payload;
              break;
            }
            case 19n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $tRequired = payload;
              break;
            }
            case 20n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $uRequired = payload;
              break;
            }
            case 21n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $vRequired = payload;
              break;
            }
            case 22n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $wRequired = payload;
              break;
            }
            case 23n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $xRequired = payload;
              break;
            }
            case 24n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $yRequired = payload;
              break;
            }
            case 25n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $zRequired = payload;
              break;
            }
            case 26n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $aaRequired = payload;
              break;
            }
            case 28n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              $aAsymmetric = payload;
              break;
            }
            case 29n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              offset += oldOffset;
              $bAsymmetric = payload;
              break;
            }
            case 30n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              offset += oldOffset;
              $cAsymmetric = payload;
              break;
            }
            case 31n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              offset += oldOffset;
              $dAsymmetric = payload;
              break;
            }
            case 32n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $eAsymmetric = payload;
              break;
            }
            case 33n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $fAsymmetric = payload;
              break;
            }
            case 34n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $gAsymmetric = payload;
              break;
            }
            case 35n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $hAsymmetric = payload;
              break;
            }
            case 36n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $iAsymmetric = payload;
              break;
            }
            case 37n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $jAsymmetric = payload;
              break;
            }
            case 38n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $kAsymmetric = payload;
              break;
            }
            case 39n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $lAsymmetric = payload;
              break;
            }
            case 40n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $mAsymmetric = payload;
              break;
            }
            case 41n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $nAsymmetric = payload;
              break;
            }
            case 42n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $oAsymmetric = payload;
              break;
            }
            case 43n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $pAsymmetric = payload;
              break;
            }
            case 44n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $qAsymmetric = payload;
              break;
            }
            case 45n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $rAsymmetric = payload;
              break;
            }
            case 46n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $sAsymmetric = payload;
              break;
            }
            case 47n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $tAsymmetric = payload;
              break;
            }
            case 48n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $uAsymmetric = payload;
              break;
            }
            case 49n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $vAsymmetric = payload;
              break;
            }
            case 50n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $wAsymmetric = payload;
              break;
            }
            case 51n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $xAsymmetric = payload;
              break;
            }
            case 52n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $yAsymmetric = payload;
              break;
            }
            case 53n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $zAsymmetric = payload;
              break;
            }
            case 54n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $aaAsymmetric = payload;
              break;
            }
            case 56n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              $aOptional = payload;
              break;
            }
            case 57n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              offset += oldOffset;
              $bOptional = payload;
              break;
            }
            case 58n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              offset += oldOffset;
              $cOptional = payload;
              break;
            }
            case 59n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              offset += oldOffset;
              $dOptional = payload;
              break;
            }
            case 60n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $eOptional = payload;
              break;
            }
            case 61n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $fOptional = payload;
              break;
            }
            case 62n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $gOptional = payload;
              break;
            }
            case 63n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $hOptional = payload;
              break;
            }
            case 64n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $iOptional = payload;
              break;
            }
            case 65n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $jOptional = payload;
              break;
            }
            case 66n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $kOptional = payload;
              break;
            }
            case 67n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $lOptional = payload;
              break;
            }
            case 68n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $mOptional = payload;
              break;
            }
            case 69n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $nOptional = payload;
              break;
            }
            case 70n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $oOptional = payload;
              break;
            }
            case 71n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $pOptional = payload;
              break;
            }
            case 72n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $qOptional = payload;
              break;
            }
            case 73n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $rOptional = payload;
              break;
            }
            case 74n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $sOptional = payload;
              break;
            }
            case 75n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $tOptional = payload;
              break;
            }
            case 76n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $uOptional = payload;
              break;
            }
            case 77n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $vOptional = payload;
              break;
            }
            case 78n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $wOptional = payload;
              break;
            }
            case 79n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $xOptional = payload;
              break;
            }
            case 80n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $yOptional = payload;
              break;
            }
            case 81n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $zOptional = payload;
              break;
            }
            case 82n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $aaOptional = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if ($aRequired === undefined || $bRequired === undefined || $cRequired === undefined || $dRequired === undefined || $eRequired === undefined || $fRequired === undefined || $gRequired === undefined || $hRequired === undefined || $iRequired === undefined || $jRequired === undefined || $kRequired === undefined || $lRequired === undefined || $mRequired === undefined || $nRequired === undefined || $oRequired === undefined || $pRequired === undefined || $qRequired === undefined || $rRequired === undefined || $sRequired === undefined || $tRequired === undefined || $uRequired === undefined || $vRequired === undefined || $wRequired === undefined || $xRequired === undefined || $yRequired === undefined || $zRequired === undefined || $aaRequired === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return {
          aRequired: $aRequired,
          bRequired: $bRequired,
          cRequired: $cRequired,
          dRequired: $dRequired,
          eRequired: $eRequired,
          fRequired: $fRequired,
          gRequired: $gRequired,
          hRequired: $hRequired,
          iRequired: $iRequired,
          jRequired: $jRequired,
          kRequired: $kRequired,
          lRequired: $lRequired,
          mRequired: $mRequired,
          nRequired: $nRequired,
          oRequired: $oRequired,
          pRequired: $pRequired,
          qRequired: $qRequired,
          rRequired: $rRequired,
          sRequired: $sRequired,
          tRequired: $tRequired,
          uRequired: $uRequired,
          vRequired: $vRequired,
          wRequired: $wRequired,
          xRequired: $xRequired,
          yRequired: $yRequired,
          zRequired: $zRequired,
          aaRequired: $aaRequired,
          aAsymmetric: $aAsymmetric,
          bAsymmetric: $bAsymmetric,
          cAsymmetric: $cAsymmetric,
          dAsymmetric: $dAsymmetric,
          eAsymmetric: $eAsymmetric,
          fAsymmetric: $fAsymmetric,
          gAsymmetric: $gAsymmetric,
          hAsymmetric: $hAsymmetric,
          iAsymmetric: $iAsymmetric,
          jAsymmetric: $jAsymmetric,
          kAsymmetric: $kAsymmetric,
          lAsymmetric: $lAsymmetric,
          mAsymmetric: $mAsymmetric,
          nAsymmetric: $nAsymmetric,
          oAsymmetric: $oAsymmetric,
          pAsymmetric: $pAsymmetric,
          qAsymmetric: $qAsymmetric,
          rAsymmetric: $rAsymmetric,
          sAsymmetric: $sAsymmetric,
          tAsymmetric: $tAsymmetric,
          uAsymmetric: $uAsymmetric,
          vAsymmetric: $vAsymmetric,
          wAsymmetric: $wAsymmetric,
          xAsymmetric: $xAsymmetric,
          yAsymmetric: $yAsymmetric,
          zAsymmetric: $zAsymmetric,
          aaAsymmetric: $aaAsymmetric,
          aOptional: $aOptional,
          bOptional: $bOptional,
          cOptional: $cOptional,
          dOptional: $dOptional,
          eOptional: $eOptional,
          fOptional: $fOptional,
          gOptional: $gOptional,
          hOptional: $hOptional,
          iOptional: $iOptional,
          jOptional: $jOptional,
          kOptional: $kOptional,
          lOptional: $lOptional,
          mOptional: $mOptional,
          nOptional: $nOptional,
          oOptional: $oOptional,
          pOptional: $pOptional,
          qOptional: $qOptional,
          rOptional: $rOptional,
          sOptional: $sOptional,
          tOptional: $tOptional,
          uOptional: $uOptional,
          vOptional: $vOptional,
          wOptional: $wOptional,
          xOptional: $xOptional,
          yOptional: $yOptional,
          zOptional: $zOptional,
          aaOptional: $aaOptional,
        };
      }

      export function outToIn(value: FooOut): FooIn {
        return value;
      }
    }

    export type BarOut =
      | { $field: 'aRequired' }
      | { $field: 'bRequired'; bRequired: number }
      | { $field: 'cRequired'; cRequired: bigint }
      | { $field: 'dRequired'; dRequired: bigint }
      | { $field: 'eRequired'; eRequired: boolean }
      | { $field: 'fRequired'; fRequired: ArrayBuffer }
      | { $field: 'gRequired'; gRequired: string }
      | { $field: 'hRequired'; hRequired: Comprehensive.Types.LocalStructOut }
      | { $field: 'iRequired'; iRequired: Degenerate.Types.EmptyStructOut }
      | { $field: 'jRequired'; jRequired: null[] }
      | { $field: 'kRequired'; kRequired: number[] }
      | { $field: 'lRequired'; lRequired: bigint[] }
      | { $field: 'mRequired'; mRequired: bigint[] }
      | { $field: 'nRequired'; nRequired: boolean[] }
      | { $field: 'oRequired'; oRequired: ArrayBuffer[] }
      | { $field: 'pRequired'; pRequired: string[] }
      | { $field: 'qRequired'; qRequired: Comprehensive.Types.LocalStructOut[] }
      | { $field: 'rRequired'; rRequired: Degenerate.Types.EmptyStructOut[] }
      | { $field: 'sRequired'; sRequired: null[][] }
      | { $field: 'tRequired'; tRequired: number[][] }
      | { $field: 'uRequired'; uRequired: bigint[][] }
      | { $field: 'vRequired'; vRequired: bigint[][] }
      | { $field: 'wRequired'; wRequired: boolean[][] }
      | { $field: 'xRequired'; xRequired: ArrayBuffer[][] }
      | { $field: 'yRequired'; yRequired: string[][] }
      | { $field: 'zRequired'; zRequired: Comprehensive.Types.LocalStructOut[][] }
      | { $field: 'aaRequired'; aaRequired: Degenerate.Types.EmptyStructOut[][] }
      | { $field: 'aAsymmetric'; $fallback: BarOut }
      | { $field: 'bAsymmetric'; bAsymmetric: number; $fallback: BarOut }
      | { $field: 'cAsymmetric'; cAsymmetric: bigint; $fallback: BarOut }
      | { $field: 'dAsymmetric'; dAsymmetric: bigint; $fallback: BarOut }
      | { $field: 'eAsymmetric'; eAsymmetric: boolean; $fallback: BarOut }
      | { $field: 'fAsymmetric'; fAsymmetric: ArrayBuffer; $fallback: BarOut }
      | { $field: 'gAsymmetric'; gAsymmetric: string; $fallback: BarOut }
      | { $field: 'hAsymmetric'; hAsymmetric: Comprehensive.Types.LocalStructOut; $fallback: BarOut }
      | { $field: 'iAsymmetric'; iAsymmetric: Degenerate.Types.EmptyStructOut; $fallback: BarOut }
      | { $field: 'jAsymmetric'; jAsymmetric: null[]; $fallback: BarOut }
      | { $field: 'kAsymmetric'; kAsymmetric: number[]; $fallback: BarOut }
      | { $field: 'lAsymmetric'; lAsymmetric: bigint[]; $fallback: BarOut }
      | { $field: 'mAsymmetric'; mAsymmetric: bigint[]; $fallback: BarOut }
      | { $field: 'nAsymmetric'; nAsymmetric: boolean[]; $fallback: BarOut }
      | { $field: 'oAsymmetric'; oAsymmetric: ArrayBuffer[]; $fallback: BarOut }
      | { $field: 'pAsymmetric'; pAsymmetric: string[]; $fallback: BarOut }
      | { $field: 'qAsymmetric'; qAsymmetric: Comprehensive.Types.LocalStructOut[]; $fallback: BarOut }
      | { $field: 'rAsymmetric'; rAsymmetric: Degenerate.Types.EmptyStructOut[]; $fallback: BarOut }
      | { $field: 'sAsymmetric'; sAsymmetric: null[][]; $fallback: BarOut }
      | { $field: 'tAsymmetric'; tAsymmetric: number[][]; $fallback: BarOut }
      | { $field: 'uAsymmetric'; uAsymmetric: bigint[][]; $fallback: BarOut }
      | { $field: 'vAsymmetric'; vAsymmetric: bigint[][]; $fallback: BarOut }
      | { $field: 'wAsymmetric'; wAsymmetric: boolean[][]; $fallback: BarOut }
      | { $field: 'xAsymmetric'; xAsymmetric: ArrayBuffer[][]; $fallback: BarOut }
      | { $field: 'yAsymmetric'; yAsymmetric: string[][]; $fallback: BarOut }
      | { $field: 'zAsymmetric'; zAsymmetric: Comprehensive.Types.LocalStructOut[][]; $fallback: BarOut }
      | { $field: 'aaAsymmetric'; aaAsymmetric: Degenerate.Types.EmptyStructOut[][]; $fallback: BarOut }
      | { $field: 'aOptional'; $fallback: BarOut }
      | { $field: 'bOptional'; bOptional: number; $fallback: BarOut }
      | { $field: 'cOptional'; cOptional: bigint; $fallback: BarOut }
      | { $field: 'dOptional'; dOptional: bigint; $fallback: BarOut }
      | { $field: 'eOptional'; eOptional: boolean; $fallback: BarOut }
      | { $field: 'fOptional'; fOptional: ArrayBuffer; $fallback: BarOut }
      | { $field: 'gOptional'; gOptional: string; $fallback: BarOut }
      | { $field: 'hOptional'; hOptional: Comprehensive.Types.LocalStructOut; $fallback: BarOut }
      | { $field: 'iOptional'; iOptional: Degenerate.Types.EmptyStructOut; $fallback: BarOut }
      | { $field: 'jOptional'; jOptional: null[]; $fallback: BarOut }
      | { $field: 'kOptional'; kOptional: number[]; $fallback: BarOut }
      | { $field: 'lOptional'; lOptional: bigint[]; $fallback: BarOut }
      | { $field: 'mOptional'; mOptional: bigint[]; $fallback: BarOut }
      | { $field: 'nOptional'; nOptional: boolean[]; $fallback: BarOut }
      | { $field: 'oOptional'; oOptional: ArrayBuffer[]; $fallback: BarOut }
      | { $field: 'pOptional'; pOptional: string[]; $fallback: BarOut }
      | { $field: 'qOptional'; qOptional: Comprehensive.Types.LocalStructOut[]; $fallback: BarOut }
      | { $field: 'rOptional'; rOptional: Degenerate.Types.EmptyStructOut[]; $fallback: BarOut }
      | { $field: 'sOptional'; sOptional: null[][]; $fallback: BarOut }
      | { $field: 'tOptional'; tOptional: number[][]; $fallback: BarOut }
      | { $field: 'uOptional'; uOptional: bigint[][]; $fallback: BarOut }
      | { $field: 'vOptional'; vOptional: bigint[][]; $fallback: BarOut }
      | { $field: 'wOptional'; wOptional: boolean[][]; $fallback: BarOut }
      | { $field: 'xOptional'; xOptional: ArrayBuffer[][]; $fallback: BarOut }
      | { $field: 'yOptional'; yOptional: string[][]; $fallback: BarOut }
      | { $field: 'zOptional'; zOptional: Comprehensive.Types.LocalStructOut[][]; $fallback: BarOut }
      | { $field: 'aaOptional'; aaOptional: Degenerate.Types.EmptyStructOut[][]; $fallback: BarOut };

    export type BarIn =
      | { $field: 'aRequired' }
      | { $field: 'bRequired'; bRequired: number }
      | { $field: 'cRequired'; cRequired: bigint }
      | { $field: 'dRequired'; dRequired: bigint }
      | { $field: 'eRequired'; eRequired: boolean }
      | { $field: 'fRequired'; fRequired: ArrayBuffer }
      | { $field: 'gRequired'; gRequired: string }
      | { $field: 'hRequired'; hRequired: Comprehensive.Types.LocalStructIn }
      | { $field: 'iRequired'; iRequired: Degenerate.Types.EmptyStructIn }
      | { $field: 'jRequired'; jRequired: null[] }
      | { $field: 'kRequired'; kRequired: number[] }
      | { $field: 'lRequired'; lRequired: bigint[] }
      | { $field: 'mRequired'; mRequired: bigint[] }
      | { $field: 'nRequired'; nRequired: boolean[] }
      | { $field: 'oRequired'; oRequired: ArrayBuffer[] }
      | { $field: 'pRequired'; pRequired: string[] }
      | { $field: 'qRequired'; qRequired: Comprehensive.Types.LocalStructIn[] }
      | { $field: 'rRequired'; rRequired: Degenerate.Types.EmptyStructIn[] }
      | { $field: 'sRequired'; sRequired: null[][] }
      | { $field: 'tRequired'; tRequired: number[][] }
      | { $field: 'uRequired'; uRequired: bigint[][] }
      | { $field: 'vRequired'; vRequired: bigint[][] }
      | { $field: 'wRequired'; wRequired: boolean[][] }
      | { $field: 'xRequired'; xRequired: ArrayBuffer[][] }
      | { $field: 'yRequired'; yRequired: string[][] }
      | { $field: 'zRequired'; zRequired: Comprehensive.Types.LocalStructIn[][] }
      | { $field: 'aaRequired'; aaRequired: Degenerate.Types.EmptyStructIn[][] }
      | { $field: 'aAsymmetric' }
      | { $field: 'bAsymmetric'; bAsymmetric: number }
      | { $field: 'cAsymmetric'; cAsymmetric: bigint }
      | { $field: 'dAsymmetric'; dAsymmetric: bigint }
      | { $field: 'eAsymmetric'; eAsymmetric: boolean }
      | { $field: 'fAsymmetric'; fAsymmetric: ArrayBuffer }
      | { $field: 'gAsymmetric'; gAsymmetric: string }
      | { $field: 'hAsymmetric'; hAsymmetric: Comprehensive.Types.LocalStructIn }
      | { $field: 'iAsymmetric'; iAsymmetric: Degenerate.Types.EmptyStructIn }
      | { $field: 'jAsymmetric'; jAsymmetric: null[] }
      | { $field: 'kAsymmetric'; kAsymmetric: number[] }
      | { $field: 'lAsymmetric'; lAsymmetric: bigint[] }
      | { $field: 'mAsymmetric'; mAsymmetric: bigint[] }
      | { $field: 'nAsymmetric'; nAsymmetric: boolean[] }
      | { $field: 'oAsymmetric'; oAsymmetric: ArrayBuffer[] }
      | { $field: 'pAsymmetric'; pAsymmetric: string[] }
      | { $field: 'qAsymmetric'; qAsymmetric: Comprehensive.Types.LocalStructIn[] }
      | { $field: 'rAsymmetric'; rAsymmetric: Degenerate.Types.EmptyStructIn[] }
      | { $field: 'sAsymmetric'; sAsymmetric: null[][] }
      | { $field: 'tAsymmetric'; tAsymmetric: number[][] }
      | { $field: 'uAsymmetric'; uAsymmetric: bigint[][] }
      | { $field: 'vAsymmetric'; vAsymmetric: bigint[][] }
      | { $field: 'wAsymmetric'; wAsymmetric: boolean[][] }
      | { $field: 'xAsymmetric'; xAsymmetric: ArrayBuffer[][] }
      | { $field: 'yAsymmetric'; yAsymmetric: string[][] }
      | { $field: 'zAsymmetric'; zAsymmetric: Comprehensive.Types.LocalStructIn[][] }
      | { $field: 'aaAsymmetric'; aaAsymmetric: Degenerate.Types.EmptyStructIn[][] }
      | { $field: 'aOptional'; $fallback: BarIn }
      | { $field: 'bOptional'; bOptional: number; $fallback: BarIn }
      | { $field: 'cOptional'; cOptional: bigint; $fallback: BarIn }
      | { $field: 'dOptional'; dOptional: bigint; $fallback: BarIn }
      | { $field: 'eOptional'; eOptional: boolean; $fallback: BarIn }
      | { $field: 'fOptional'; fOptional: ArrayBuffer; $fallback: BarIn }
      | { $field: 'gOptional'; gOptional: string; $fallback: BarIn }
      | { $field: 'hOptional'; hOptional: Comprehensive.Types.LocalStructIn; $fallback: BarIn }
      | { $field: 'iOptional'; iOptional: Degenerate.Types.EmptyStructIn; $fallback: BarIn }
      | { $field: 'jOptional'; jOptional: null[]; $fallback: BarIn }
      | { $field: 'kOptional'; kOptional: number[]; $fallback: BarIn }
      | { $field: 'lOptional'; lOptional: bigint[]; $fallback: BarIn }
      | { $field: 'mOptional'; mOptional: bigint[]; $fallback: BarIn }
      | { $field: 'nOptional'; nOptional: boolean[]; $fallback: BarIn }
      | { $field: 'oOptional'; oOptional: ArrayBuffer[]; $fallback: BarIn }
      | { $field: 'pOptional'; pOptional: string[]; $fallback: BarIn }
      | { $field: 'qOptional'; qOptional: Comprehensive.Types.LocalStructIn[]; $fallback: BarIn }
      | { $field: 'rOptional'; rOptional: Degenerate.Types.EmptyStructIn[]; $fallback: BarIn }
      | { $field: 'sOptional'; sOptional: null[][]; $fallback: BarIn }
      | { $field: 'tOptional'; tOptional: number[][]; $fallback: BarIn }
      | { $field: 'uOptional'; uOptional: bigint[][]; $fallback: BarIn }
      | { $field: 'vOptional'; vOptional: bigint[][]; $fallback: BarIn }
      | { $field: 'wOptional'; wOptional: boolean[][]; $fallback: BarIn }
      | { $field: 'xOptional'; xOptional: ArrayBuffer[][]; $fallback: BarIn }
      | { $field: 'yOptional'; yOptional: string[][]; $fallback: BarIn }
      | { $field: 'zOptional'; zOptional: Comprehensive.Types.LocalStructIn[][]; $fallback: BarIn }
      | { $field: 'aaOptional'; aaOptional: Degenerate.Types.EmptyStructIn[][]; $fallback: BarIn };

    export namespace Bar {
      export function size(value: BarOut): number {
        let payloadSize = 0;

        switch (value.$field) {
          case 'aRequired': {
            const payload = null;
            payloadSize = 0;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'bRequired': {
            const payload = value.bRequired;
            if (Object.is(payload, 0)) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize;
          }
          case 'cRequired': {
            const payload = value.cRequired;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(2n, payloadSize, true) + payloadSize;
          }
          case 'dRequired': {
            const payload = value.dRequired;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(3n, payloadSize, true) + payloadSize;
          }
          case 'eRequired': {
            const payload = value.eRequired;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(4n, payloadSize, true) + payloadSize;
          }
          case 'fRequired': {
            const payload = value.fRequired;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize;
          }
          case 'gRequired': {
            const payload = value.gRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize;
          }
          case 'hRequired': {
            const payload = value.hRequired;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            return fieldHeaderSize(7n, payloadSize, false) + payloadSize;
          }
          case 'iRequired': {
            const payload = value.iRequired;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize;
          }
          case 'jRequired': {
            const payload = value.jRequired;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(9n, payloadSize, false) + payloadSize;
          }
          case 'kRequired': {
            const payload = value.kRequired;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize;
          }
          case 'lRequired': {
            const payload = value.lRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(11n, payloadSize, false) + payloadSize;
          }
          case 'mRequired': {
            const payload = value.mRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(12n, payloadSize, false) + payloadSize;
          }
          case 'nRequired': {
            const payload = value.nRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(13n, payloadSize, false) + payloadSize;
          }
          case 'oRequired': {
            const payload = value.oRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(14n, payloadSize, false) + payloadSize;
          }
          case 'pRequired': {
            const payload = value.pRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(15n, payloadSize, false) + payloadSize;
          }
          case 'qRequired': {
            const payload = value.qRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(16n, payloadSize, false) + payloadSize;
          }
          case 'rRequired': {
            const payload = value.rRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(17n, payloadSize, false) + payloadSize;
          }
          case 'sRequired': {
            const payload = value.sRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(18n, payloadSize, false) + payloadSize;
          }
          case 'tRequired': {
            const payload = value.tRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(19n, payloadSize, false) + payloadSize;
          }
          case 'uRequired': {
            const payload = value.uRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(20n, payloadSize, false) + payloadSize;
          }
          case 'vRequired': {
            const payload = value.vRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(21n, payloadSize, false) + payloadSize;
          }
          case 'wRequired': {
            const payload = value.wRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(22n, payloadSize, false) + payloadSize;
          }
          case 'xRequired': {
            const payload = value.xRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(23n, payloadSize, false) + payloadSize;
          }
          case 'yRequired': {
            const payload = value.yRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(24n, payloadSize, false) + payloadSize;
          }
          case 'zRequired': {
            const payload = value.zRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(25n, payloadSize, false) + payloadSize;
          }
          case 'aaRequired': {
            const payload = value.aaRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(26n, payloadSize, false) + payloadSize;
          }
          case 'aAsymmetric': {
            const payload = null;
            payloadSize = 0;
            return fieldHeaderSize(28n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'bAsymmetric': {
            const payload = value.bAsymmetric;
            if (Object.is(payload, 0)) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(29n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'cAsymmetric': {
            const payload = value.cAsymmetric;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(30n, payloadSize, true) + payloadSize + size(value.$fallback);
          }
          case 'dAsymmetric': {
            const payload = value.dAsymmetric;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(31n, payloadSize, true) + payloadSize + size(value.$fallback);
          }
          case 'eAsymmetric': {
            const payload = value.eAsymmetric;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(32n, payloadSize, true) + payloadSize + size(value.$fallback);
          }
          case 'fAsymmetric': {
            const payload = value.fAsymmetric;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(33n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'gAsymmetric': {
            const payload = value.gAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(34n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'hAsymmetric': {
            const payload = value.hAsymmetric;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            return fieldHeaderSize(35n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'iAsymmetric': {
            const payload = value.iAsymmetric;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            return fieldHeaderSize(36n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'jAsymmetric': {
            const payload = value.jAsymmetric;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(37n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'kAsymmetric': {
            const payload = value.kAsymmetric;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(38n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'lAsymmetric': {
            const payload = value.lAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(39n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'mAsymmetric': {
            const payload = value.mAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(40n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'nAsymmetric': {
            const payload = value.nAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(41n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'oAsymmetric': {
            const payload = value.oAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(42n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'pAsymmetric': {
            const payload = value.pAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(43n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'qAsymmetric': {
            const payload = value.qAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(44n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'rAsymmetric': {
            const payload = value.rAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(45n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'sAsymmetric': {
            const payload = value.sAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(46n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'tAsymmetric': {
            const payload = value.tAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(47n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'uAsymmetric': {
            const payload = value.uAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(48n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'vAsymmetric': {
            const payload = value.vAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(49n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'wAsymmetric': {
            const payload = value.wAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(50n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'xAsymmetric': {
            const payload = value.xAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(51n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'yAsymmetric': {
            const payload = value.yAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(52n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'zAsymmetric': {
            const payload = value.zAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(53n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'aaAsymmetric': {
            const payload = value.aaAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(54n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'aOptional': {
            const payload = null;
            payloadSize = 0;
            return fieldHeaderSize(56n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'bOptional': {
            const payload = value.bOptional;
            if (Object.is(payload, 0)) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(57n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'cOptional': {
            const payload = value.cOptional;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(58n, payloadSize, true) + payloadSize + size(value.$fallback);
          }
          case 'dOptional': {
            const payload = value.dOptional;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(59n, payloadSize, true) + payloadSize + size(value.$fallback);
          }
          case 'eOptional': {
            const payload = value.eOptional;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(60n, payloadSize, true) + payloadSize + size(value.$fallback);
          }
          case 'fOptional': {
            const payload = value.fOptional;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(61n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'gOptional': {
            const payload = value.gOptional;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(62n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'hOptional': {
            const payload = value.hOptional;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            return fieldHeaderSize(63n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'iOptional': {
            const payload = value.iOptional;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            return fieldHeaderSize(64n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'jOptional': {
            const payload = value.jOptional;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(65n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'kOptional': {
            const payload = value.kOptional;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(66n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'lOptional': {
            const payload = value.lOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(67n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'mOptional': {
            const payload = value.mOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(68n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'nOptional': {
            const payload = value.nOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(69n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'oOptional': {
            const payload = value.oOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(70n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'pOptional': {
            const payload = value.pOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(71n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'qOptional': {
            const payload = value.qOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(72n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'rOptional': {
            const payload = value.rOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(73n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'sOptional': {
            const payload = value.sOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(74n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'tOptional': {
            const payload = value.tOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(75n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'uOptional': {
            const payload = value.uOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(76n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'vOptional': {
            const payload = value.vOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(77n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'wOptional': {
            const payload = value.wOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(78n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'xOptional': {
            const payload = value.xOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(79n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'yOptional': {
            const payload = value.yOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(80n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'zOptional': {
            const payload = value.zOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(81n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'aaOptional': {
            const payload = value.aaOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(82n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: BarOut,
      ): number {
        let payloadSize = 0;

        switch (value.$field) {
          case 'aRequired': {
            const payload = null;
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            return offset;
          }
          case 'bRequired': {
            const payload = value.bRequired;
            if (Object.is(payload, 0)) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
            return offset;
          }
          case 'cRequired': {
            const payload = value.cRequired;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'dRequired': {
            const payload = value.dRequired;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'eRequired': {
            const payload = value.eRequired;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'fRequired': {
            const payload = value.fRequired;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const sourceBuffer = new Uint8Array(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            return offset;
          }
          case 'gRequired': {
            const payload = value.gRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            return offset;
          }
          case 'hRequired': {
            const payload = value.hRequired;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
            offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
            return offset;
          }
          case 'iRequired': {
            const payload = value.iRequired;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
            return offset;
          }
          case 'jRequired': {
            const payload = value.jRequired;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'kRequired': {
            const payload = value.kRequired;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
                offset += 8;
              }
            }
            return offset;
          }
          case 'lRequired': {
            const payload = value.lRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'mRequired': {
            const payload = value.mRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'nRequired': {
            const payload = value.nRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'oRequired': {
            const payload = value.oRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const sourceBuffer = new Uint8Array(payload);
                  const targetBuffer = new Uint8Array(
                    dataView.buffer,
                    dataView.byteOffset,
                    dataView.byteLength,
                  );
                  targetBuffer.set(sourceBuffer, offset);
                  offset += sourceBuffer.byteLength;
                }
              }
            }
            return offset;
          }
          case 'pRequired': {
            const payload = value.pRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 15n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const sourceBuffer = textEncoder.encode(payload);
                  const targetBuffer = new Uint8Array(
                    dataView.buffer,
                    dataView.byteOffset,
                    dataView.byteLength,
                  );
                  targetBuffer.set(sourceBuffer, offset);
                  offset += sourceBuffer.byteLength;
                }
              }
            }
            return offset;
          }
          case 'qRequired': {
            const payload = value.qRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 16n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
              }
            }
            return offset;
          }
          case 'rRequired': {
            const payload = value.rRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
              }
            }
            return offset;
          }
          case 'sRequired': {
            const payload = value.sRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const varint = BigInt(payload.length);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'tRequired': {
            const payload = value.tRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 19n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 8 * payload.length;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = 8;
                    dataView.setFloat64(offset, payload, true);
                    offset += 8;
                  }
                }
              }
            }
            return offset;
          }
          case 'uRequired': {
            const payload = value.uRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 20n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = varintSizeFromValue(payload);
                    {
                      const varint = payload;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            return offset;
          }
          case 'vRequired': {
            const payload = value.vRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 21n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    {
                      const varint = zigzagEncode(payload);
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            return offset;
          }
          case 'wRequired': {
            const payload = value.wRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 22n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = 1;
                    {
                      const varint = payload ? 1n : 0n;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            return offset;
          }
          case 'xRequired': {
            const payload = value.xRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 23n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = payload.byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const sourceBuffer = new Uint8Array(payload);
                      const targetBuffer = new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset,
                        dataView.byteLength,
                      );
                      targetBuffer.set(sourceBuffer, offset);
                      offset += sourceBuffer.byteLength;
                    }
                  }
                }
              }
            }
            return offset;
          }
          case 'yRequired': {
            const payload = value.yRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 24n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const sourceBuffer = textEncoder.encode(payload);
                      const targetBuffer = new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset,
                        dataView.byteLength,
                      );
                      targetBuffer.set(sourceBuffer, offset);
                      offset += sourceBuffer.byteLength;
                    }
                  }
                }
              }
            }
            return offset;
          }
          case 'zRequired': {
            const payload = value.zRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 25n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            return offset;
          }
          case 'aaRequired': {
            const payload = value.aaRequired;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 26n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            return offset;
          }
          case 'aAsymmetric': {
            const payload = null;
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 28n, payloadSize, false);
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'bAsymmetric': {
            const payload = value.bAsymmetric;
            if (Object.is(payload, 0)) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 29n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'cAsymmetric': {
            const payload = value.cAsymmetric;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 30n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'dAsymmetric': {
            const payload = value.dAsymmetric;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 31n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'eAsymmetric': {
            const payload = value.eAsymmetric;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 32n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'fAsymmetric': {
            const payload = value.fAsymmetric;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 33n, payloadSize, false);
            {
              const sourceBuffer = new Uint8Array(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'gAsymmetric': {
            const payload = value.gAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 34n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'hAsymmetric': {
            const payload = value.hAsymmetric;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 35n, payloadSize, false);
            offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'iAsymmetric': {
            const payload = value.iAsymmetric;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 36n, payloadSize, false);
            offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'jAsymmetric': {
            const payload = value.jAsymmetric;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 37n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'kAsymmetric': {
            const payload = value.kAsymmetric;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 38n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
                offset += 8;
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'lAsymmetric': {
            const payload = value.lAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 39n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'mAsymmetric': {
            const payload = value.mAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 40n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'nAsymmetric': {
            const payload = value.nAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 41n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'oAsymmetric': {
            const payload = value.oAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 42n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const sourceBuffer = new Uint8Array(payload);
                  const targetBuffer = new Uint8Array(
                    dataView.buffer,
                    dataView.byteOffset,
                    dataView.byteLength,
                  );
                  targetBuffer.set(sourceBuffer, offset);
                  offset += sourceBuffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'pAsymmetric': {
            const payload = value.pAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 43n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const sourceBuffer = textEncoder.encode(payload);
                  const targetBuffer = new Uint8Array(
                    dataView.buffer,
                    dataView.byteOffset,
                    dataView.byteLength,
                  );
                  targetBuffer.set(sourceBuffer, offset);
                  offset += sourceBuffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'qAsymmetric': {
            const payload = value.qAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 44n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'rAsymmetric': {
            const payload = value.rAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 45n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'sAsymmetric': {
            const payload = value.sAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 46n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const varint = BigInt(payload.length);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'tAsymmetric': {
            const payload = value.tAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 47n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 8 * payload.length;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = 8;
                    dataView.setFloat64(offset, payload, true);
                    offset += 8;
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'uAsymmetric': {
            const payload = value.uAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 48n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = varintSizeFromValue(payload);
                    {
                      const varint = payload;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'vAsymmetric': {
            const payload = value.vAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 49n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    {
                      const varint = zigzagEncode(payload);
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'wAsymmetric': {
            const payload = value.wAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 50n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = 1;
                    {
                      const varint = payload ? 1n : 0n;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'xAsymmetric': {
            const payload = value.xAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 51n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = payload.byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const sourceBuffer = new Uint8Array(payload);
                      const targetBuffer = new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset,
                        dataView.byteLength,
                      );
                      targetBuffer.set(sourceBuffer, offset);
                      offset += sourceBuffer.byteLength;
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'yAsymmetric': {
            const payload = value.yAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 52n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const sourceBuffer = textEncoder.encode(payload);
                      const targetBuffer = new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset,
                        dataView.byteLength,
                      );
                      targetBuffer.set(sourceBuffer, offset);
                      offset += sourceBuffer.byteLength;
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'zAsymmetric': {
            const payload = value.zAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 53n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'aaAsymmetric': {
            const payload = value.aaAsymmetric;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 54n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'aOptional': {
            const payload = null;
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 56n, payloadSize, false);
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'bOptional': {
            const payload = value.bOptional;
            if (Object.is(payload, 0)) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 57n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'cOptional': {
            const payload = value.cOptional;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 58n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'dOptional': {
            const payload = value.dOptional;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 59n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'eOptional': {
            const payload = value.eOptional;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 60n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'fOptional': {
            const payload = value.fOptional;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 61n, payloadSize, false);
            {
              const sourceBuffer = new Uint8Array(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'gOptional': {
            const payload = value.gOptional;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 62n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'hOptional': {
            const payload = value.hOptional;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 63n, payloadSize, false);
            offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'iOptional': {
            const payload = value.iOptional;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 64n, payloadSize, false);
            offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'jOptional': {
            const payload = value.jOptional;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 65n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'kOptional': {
            const payload = value.kOptional;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 66n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
                offset += 8;
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'lOptional': {
            const payload = value.lOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 67n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'mOptional': {
            const payload = value.mOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 68n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'nOptional': {
            const payload = value.nOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 69n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'oOptional': {
            const payload = value.oOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 70n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const sourceBuffer = new Uint8Array(payload);
                  const targetBuffer = new Uint8Array(
                    dataView.buffer,
                    dataView.byteOffset,
                    dataView.byteLength,
                  );
                  targetBuffer.set(sourceBuffer, offset);
                  offset += sourceBuffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'pOptional': {
            const payload = value.pOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 71n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const sourceBuffer = textEncoder.encode(payload);
                  const targetBuffer = new Uint8Array(
                    dataView.buffer,
                    dataView.byteOffset,
                    dataView.byteLength,
                  );
                  targetBuffer.set(sourceBuffer, offset);
                  offset += sourceBuffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'qOptional': {
            const payload = value.qOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 72n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'rOptional': {
            const payload = value.rOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 73n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'sOptional': {
            const payload = value.sOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 74n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const varint = BigInt(payload.length);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'tOptional': {
            const payload = value.tOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 75n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                payloadSize = 8 * payload.length;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = 8;
                    dataView.setFloat64(offset, payload, true);
                    offset += 8;
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'uOptional': {
            const payload = value.uOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 76n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = varintSizeFromValue(payload);
                    {
                      const varint = payload;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'vOptional': {
            const payload = value.vOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 77n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    {
                      const varint = zigzagEncode(payload);
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'wOptional': {
            const payload = value.wOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 78n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = 1;
                    {
                      const varint = payload ? 1n : 0n;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'xOptional': {
            const payload = value.xOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 79n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = payload.byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const sourceBuffer = new Uint8Array(payload);
                      const targetBuffer = new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset,
                        dataView.byteLength,
                      );
                      targetBuffer.set(sourceBuffer, offset);
                      offset += sourceBuffer.byteLength;
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'yOptional': {
            const payload = value.yOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 80n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const sourceBuffer = textEncoder.encode(payload);
                      const targetBuffer = new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset,
                        dataView.byteLength,
                      );
                      targetBuffer.set(sourceBuffer, offset);
                      offset += sourceBuffer.byteLength;
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'zOptional': {
            const payload = value.zOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 81n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'aaOptional': {
            const payload = value.aaOptional;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 82n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(dataView: DataView): BarIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              return {
                $field: 'aRequired',
              };
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              return {
                $field: 'bRequired',
                bRequired: payload,
              };
            }
            case 2n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              return {
                $field: 'cRequired',
                cRequired: payload,
              };
            }
            case 3n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              return {
                $field: 'dRequired',
                dRequired: payload,
              };
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              return {
                $field: 'eRequired',
                eRequired: payload,
              };
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              return {
                $field: 'fRequired',
                fRequired: payload,
              };
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'gRequired',
                gRequired: payload,
              };
            }
            case 7n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
              offset = dataView.byteLength;
              return {
                $field: 'hRequired',
                hRequired: payload,
              };
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
              offset = dataView.byteLength;
              return {
                $field: 'iRequired',
                iRequired: payload,
              };
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              return {
                $field: 'jRequired',
                jRequired: payload,
              };
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'kRequired',
                kRequired: payload,
              };
            }
            case 11n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'lRequired',
                lRequired: payload,
              };
            }
            case 12n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'mRequired',
                mRequired: payload,
              };
            }
            case 13n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'nRequired',
                nRequired: payload,
              };
            }
            case 14n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'oRequired',
                oRequired: payload,
              };
            }
            case 15n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'pRequired',
                pRequired: payload,
              };
            }
            case 16n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'qRequired',
                qRequired: payload,
              };
            }
            case 17n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'rRequired',
                rRequired: payload,
              };
            }
            case 18n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'sRequired',
                sRequired: payload,
              };
            }
            case 19n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'tRequired',
                tRequired: payload,
              };
            }
            case 20n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'uRequired',
                uRequired: payload,
              };
            }
            case 21n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'vRequired',
                vRequired: payload,
              };
            }
            case 22n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'wRequired',
                wRequired: payload,
              };
            }
            case 23n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'xRequired',
                xRequired: payload,
              };
            }
            case 24n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'yRequired',
                yRequired: payload,
              };
            }
            case 25n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'zRequired',
                zRequired: payload,
              };
            }
            case 26n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'aaRequired',
                aaRequired: payload,
              };
            }
            case 28n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              return {
                $field: 'aAsymmetric',
              };
            }
            case 29n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              return {
                $field: 'bAsymmetric',
                bAsymmetric: payload,
              };
            }
            case 30n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              return {
                $field: 'cAsymmetric',
                cAsymmetric: payload,
              };
            }
            case 31n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              return {
                $field: 'dAsymmetric',
                dAsymmetric: payload,
              };
            }
            case 32n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              return {
                $field: 'eAsymmetric',
                eAsymmetric: payload,
              };
            }
            case 33n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              return {
                $field: 'fAsymmetric',
                fAsymmetric: payload,
              };
            }
            case 34n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'gAsymmetric',
                gAsymmetric: payload,
              };
            }
            case 35n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
              offset = dataView.byteLength;
              return {
                $field: 'hAsymmetric',
                hAsymmetric: payload,
              };
            }
            case 36n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
              offset = dataView.byteLength;
              return {
                $field: 'iAsymmetric',
                iAsymmetric: payload,
              };
            }
            case 37n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              return {
                $field: 'jAsymmetric',
                jAsymmetric: payload,
              };
            }
            case 38n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'kAsymmetric',
                kAsymmetric: payload,
              };
            }
            case 39n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'lAsymmetric',
                lAsymmetric: payload,
              };
            }
            case 40n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'mAsymmetric',
                mAsymmetric: payload,
              };
            }
            case 41n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'nAsymmetric',
                nAsymmetric: payload,
              };
            }
            case 42n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'oAsymmetric',
                oAsymmetric: payload,
              };
            }
            case 43n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'pAsymmetric',
                pAsymmetric: payload,
              };
            }
            case 44n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'qAsymmetric',
                qAsymmetric: payload,
              };
            }
            case 45n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'rAsymmetric',
                rAsymmetric: payload,
              };
            }
            case 46n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'sAsymmetric',
                sAsymmetric: payload,
              };
            }
            case 47n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'tAsymmetric',
                tAsymmetric: payload,
              };
            }
            case 48n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'uAsymmetric',
                uAsymmetric: payload,
              };
            }
            case 49n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'vAsymmetric',
                vAsymmetric: payload,
              };
            }
            case 50n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'wAsymmetric',
                wAsymmetric: payload,
              };
            }
            case 51n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'xAsymmetric',
                xAsymmetric: payload,
              };
            }
            case 52n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'yAsymmetric',
                yAsymmetric: payload,
              };
            }
            case 53n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'zAsymmetric',
                zAsymmetric: payload,
              };
            }
            case 54n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'aaAsymmetric',
                aaAsymmetric: payload,
              };
            }
            case 56n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'aOptional',
                $fallback,
              };
            }
            case 57n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'bOptional',
                bOptional: payload,
                $fallback,
              };
            }
            case 58n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'cOptional',
                cOptional: payload,
                $fallback,
              };
            }
            case 59n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'dOptional',
                dOptional: payload,
                $fallback,
              };
            }
            case 60n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'eOptional',
                eOptional: payload,
                $fallback,
              };
            }
            case 61n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'fOptional',
                fOptional: payload,
                $fallback,
              };
            }
            case 62n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'gOptional',
                gOptional: payload,
                $fallback,
              };
            }
            case 63n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'hOptional',
                hOptional: payload,
                $fallback,
              };
            }
            case 64n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'iOptional',
                iOptional: payload,
                $fallback,
              };
            }
            case 65n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'jOptional',
                jOptional: payload,
                $fallback,
              };
            }
            case 66n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'kOptional',
                kOptional: payload,
                $fallback,
              };
            }
            case 67n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'lOptional',
                lOptional: payload,
                $fallback,
              };
            }
            case 68n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'mOptional',
                mOptional: payload,
                $fallback,
              };
            }
            case 69n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'nOptional',
                nOptional: payload,
                $fallback,
              };
            }
            case 70n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'oOptional',
                oOptional: payload,
                $fallback,
              };
            }
            case 71n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'pOptional',
                pOptional: payload,
                $fallback,
              };
            }
            case 72n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'qOptional',
                qOptional: payload,
                $fallback,
              };
            }
            case 73n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'rOptional',
                rOptional: payload,
                $fallback,
              };
            }
            case 74n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'sOptional',
                sOptional: payload,
                $fallback,
              };
            }
            case 75n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'tOptional',
                tOptional: payload,
                $fallback,
              };
            }
            case 76n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'uOptional',
                uOptional: payload,
                $fallback,
              };
            }
            case 77n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'vOptional',
                vOptional: payload,
                $fallback,
              };
            }
            case 78n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'wOptional',
                wOptional: payload,
                $fallback,
              };
            }
            case 79n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'xOptional',
                xOptional: payload,
                $fallback,
              };
            }
            case 80n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'yOptional',
                yOptional: payload,
                $fallback,
              };
            }
            case 81n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'zOptional',
                zOptional: payload,
                $fallback,
              };
            }
            case 82n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserialize(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'aaOptional',
                aaOptional: payload,
                $fallback,
              };
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: BarOut): BarIn {
        return value;
      }
    }
  }
}

export namespace Degenerate {
  export namespace Types {
    export type EmptyStructOut = {
    };

    export type EmptyStructIn = {
    };

    export namespace EmptyStruct {
      export function size(value: EmptyStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: EmptyStructOut,
      ): number {
        let payloadSize = 0;

        return offset;
      }

      export function deserialize(dataView: DataView): EmptyStructIn {
        return {
        };
      }

      export function outToIn(value: EmptyStructOut): EmptyStructIn {
        return value;
      }
    }

    export type EmptyChoiceOut = never;

    export type EmptyChoiceIn = never;

    export namespace EmptyChoice {
      export function size(value: EmptyChoiceOut): number {
        return 0;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: EmptyChoiceOut,
      ): number {
        return offset;
      }

      export function deserialize(dataView: DataView): EmptyChoiceIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          offset = newOffset;
          switch (index) {
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: EmptyChoiceOut): EmptyChoiceIn {
        return value;
      }
    }
  }
}

export namespace SchemaEvolution {
  export namespace After {
    export type ExampleStructOut = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional?: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric: string;
      asymmetricToOptional?: string;
      optionalToRequired: string;
      optionalToAsymmetric: string;
      optionalToOptional?: string;
      nonexistentToAsymmetric: null;
      nonexistentToOptional?: null;
    };

    export type ExampleStructIn = {
      requiredToRequired: string;
      requiredToAsymmetric?: string;
      requiredToOptional?: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric?: string;
      asymmetricToOptional?: string;
      optionalToRequired: string;
      optionalToAsymmetric?: string;
      optionalToOptional?: string;
      nonexistentToAsymmetric?: null;
      nonexistentToOptional?: null;
    };

    export namespace ExampleStruct {
      export function size(value: ExampleStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
            valueSize += fieldHeaderSize(2n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(4n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
            valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.optionalToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(8n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
            valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.nonexistentToAsymmetric;
          payloadSize = 0;
          valueSize += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nonexistentToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = 0;
            valueSize += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
          }
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.requiredToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
          }
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.optionalToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.optionalToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
          }
        }

        {
          const payload = value.nonexistentToAsymmetric;
          payloadSize = 0;
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
        }

        {
          const payload = value.nonexistentToOptional;
          if (payload !== undefined) {
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
          }
        }

        return offset;
      }

      export function deserialize(dataView: DataView): ExampleStructIn {
        const dataViewAlias = dataView;

        let offset = 0;

        let $requiredToRequired, $requiredToAsymmetric, $requiredToOptional, $asymmetricToRequired, $asymmetricToAsymmetric, $asymmetricToOptional, $optionalToRequired, $optionalToAsymmetric, $optionalToOptional, $nonexistentToAsymmetric, $nonexistentToOptional;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToRequired = payload;
              break;
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToAsymmetric = payload;
              break;
            }
            case 2n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToOptional = payload;
              break;
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToRequired = payload;
              break;
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToAsymmetric = payload;
              break;
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToOptional = payload;
              break;
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToRequired = payload;
              break;
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToAsymmetric = payload;
              break;
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToOptional = payload;
              break;
            }
            case 13n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              $nonexistentToAsymmetric = payload;
              break;
            }
            case 14n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              $nonexistentToOptional = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if ($requiredToRequired === undefined || $asymmetricToRequired === undefined || $optionalToRequired === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return {
          requiredToRequired: $requiredToRequired,
          requiredToAsymmetric: $requiredToAsymmetric,
          requiredToOptional: $requiredToOptional,
          asymmetricToRequired: $asymmetricToRequired,
          asymmetricToAsymmetric: $asymmetricToAsymmetric,
          asymmetricToOptional: $asymmetricToOptional,
          optionalToRequired: $optionalToRequired,
          optionalToAsymmetric: $optionalToAsymmetric,
          optionalToOptional: $optionalToOptional,
          nonexistentToAsymmetric: $nonexistentToAsymmetric,
          nonexistentToOptional: $nonexistentToOptional,
        };
      }

      export function outToIn(value: ExampleStructOut): ExampleStructIn {
        return value;
      }
    }

    export type ExampleChoiceOut =
      | { $field: 'requiredToRequired'; requiredToRequired: string }
      | { $field: 'requiredToAsymmetric'; requiredToAsymmetric: string; $fallback: ExampleChoiceOut }
      | { $field: 'asymmetricToRequired'; asymmetricToRequired: string }
      | { $field: 'asymmetricToAsymmetric'; asymmetricToAsymmetric: string; $fallback: ExampleChoiceOut }
      | { $field: 'asymmetricToOptional'; asymmetricToOptional: string; $fallback: ExampleChoiceOut }
      | { $field: 'optionalToRequired'; optionalToRequired: string }
      | { $field: 'optionalToAsymmetric'; optionalToAsymmetric: string; $fallback: ExampleChoiceOut }
      | { $field: 'optionalToOptional'; optionalToOptional: string; $fallback: ExampleChoiceOut }
      | { $field: 'nonexistentToRequired' }
      | { $field: 'nonexistentToAsymmetric'; $fallback: ExampleChoiceOut }
      | { $field: 'nonexistentToOptional'; $fallback: ExampleChoiceOut };

    export type ExampleChoiceIn =
      | { $field: 'requiredToRequired'; requiredToRequired: string }
      | { $field: 'requiredToAsymmetric'; requiredToAsymmetric: string }
      | { $field: 'asymmetricToRequired'; asymmetricToRequired: string }
      | { $field: 'asymmetricToAsymmetric'; asymmetricToAsymmetric: string }
      | { $field: 'asymmetricToOptional'; asymmetricToOptional: string; $fallback: ExampleChoiceIn }
      | { $field: 'optionalToRequired'; optionalToRequired: string }
      | { $field: 'optionalToAsymmetric'; optionalToAsymmetric: string }
      | { $field: 'optionalToOptional'; optionalToOptional: string; $fallback: ExampleChoiceIn }
      | { $field: 'nonexistentToRequired' }
      | { $field: 'nonexistentToAsymmetric' }
      | { $field: 'nonexistentToOptional'; $fallback: ExampleChoiceIn };

    export namespace ExampleChoice {
      export function size(value: ExampleChoiceOut): number {
        let payloadSize = 0;

        switch (value.$field) {
          case 'requiredToRequired': {
            const payload = value.requiredToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'requiredToAsymmetric': {
            const payload = value.requiredToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'asymmetricToRequired': {
            const payload = value.asymmetricToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(4n, payloadSize, false) + payloadSize;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.asymmetricToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'asymmetricToOptional': {
            const payload = value.asymmetricToOptional;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'optionalToRequired': {
            const payload = value.optionalToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize;
          }
          case 'optionalToAsymmetric': {
            const payload = value.optionalToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(9n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'optionalToOptional': {
            const payload = value.optionalToOptional;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'nonexistentToRequired': {
            const payload = null;
            payloadSize = 0;
            return fieldHeaderSize(12n, payloadSize, false) + payloadSize;
          }
          case 'nonexistentToAsymmetric': {
            const payload = null;
            payloadSize = 0;
            return fieldHeaderSize(13n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'nonexistentToOptional': {
            const payload = null;
            payloadSize = 0;
            return fieldHeaderSize(14n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.$field) {
          case 'requiredToRequired': {
            const payload = value.requiredToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            return offset;
          }
          case 'requiredToAsymmetric': {
            const payload = value.requiredToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'asymmetricToRequired': {
            const payload = value.asymmetricToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            return offset;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.asymmetricToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'asymmetricToOptional': {
            const payload = value.asymmetricToOptional;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'optionalToRequired': {
            const payload = value.optionalToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            return offset;
          }
          case 'optionalToAsymmetric': {
            const payload = value.optionalToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'optionalToOptional': {
            const payload = value.optionalToOptional;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'nonexistentToRequired': {
            const payload = null;
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
            return offset;
          }
          case 'nonexistentToAsymmetric': {
            const payload = null;
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'nonexistentToOptional': {
            const payload = null;
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(dataView: DataView): ExampleChoiceIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'requiredToRequired',
                requiredToRequired: payload,
              };
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'requiredToAsymmetric',
                requiredToAsymmetric: payload,
              };
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToRequired',
                asymmetricToRequired: payload,
              };
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToAsymmetric',
                asymmetricToAsymmetric: payload,
              };
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'asymmetricToOptional',
                asymmetricToOptional: payload,
                $fallback,
              };
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'optionalToRequired',
                optionalToRequired: payload,
              };
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'optionalToAsymmetric',
                optionalToAsymmetric: payload,
              };
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'optionalToOptional',
                optionalToOptional: payload,
                $fallback,
              };
            }
            case 12n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              return {
                $field: 'nonexistentToRequired',
              };
            }
            case 13n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              return {
                $field: 'nonexistentToAsymmetric',
              };
            }
            case 14n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'nonexistentToOptional',
                $fallback,
              };
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: ExampleChoiceOut): ExampleChoiceIn {
        return value;
      }
    }
  }

  export namespace Before {
    export type ExampleStructOut = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional: string;
      requiredToNonexistent: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric: string;
      asymmetricToOptional: string;
      asymmetricToNonexistent: string;
      optionalToRequired?: string;
      optionalToAsymmetric?: string;
      optionalToOptional?: string;
      optionalToNonexistent?: string;
    };

    export type ExampleStructIn = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional: string;
      requiredToNonexistent: string;
      asymmetricToRequired?: string;
      asymmetricToAsymmetric?: string;
      asymmetricToOptional?: string;
      asymmetricToNonexistent?: string;
      optionalToRequired?: string;
      optionalToAsymmetric?: string;
      optionalToOptional?: string;
      optionalToNonexistent?: string;
    };

    export namespace ExampleStruct {
      export function size(value: ExampleStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(2n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(3n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(4n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(7n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalToRequired;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
            valueSize += fieldHeaderSize(8n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.optionalToAsymmetric;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
            valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.optionalToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
            valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
          }
        }

        {
          const payload = value.optionalToNonexistent;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
            valueSize += fieldHeaderSize(11n, payloadSize, false) + payloadSize;
          }
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.requiredToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.requiredToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = value.optionalToRequired;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalToAsymmetric;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalToNonexistent;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
          }
        }

        return offset;
      }

      export function deserialize(dataView: DataView): ExampleStructIn {
        const dataViewAlias = dataView;

        let offset = 0;

        let $requiredToRequired, $requiredToAsymmetric, $requiredToOptional, $requiredToNonexistent, $asymmetricToRequired, $asymmetricToAsymmetric, $asymmetricToOptional, $asymmetricToNonexistent, $optionalToRequired, $optionalToAsymmetric, $optionalToOptional, $optionalToNonexistent;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToRequired = payload;
              break;
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToAsymmetric = payload;
              break;
            }
            case 2n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToOptional = payload;
              break;
            }
            case 3n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToNonexistent = payload;
              break;
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToRequired = payload;
              break;
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToAsymmetric = payload;
              break;
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToOptional = payload;
              break;
            }
            case 7n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToNonexistent = payload;
              break;
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToRequired = payload;
              break;
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToAsymmetric = payload;
              break;
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToOptional = payload;
              break;
            }
            case 11n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToNonexistent = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if ($requiredToRequired === undefined || $requiredToAsymmetric === undefined || $requiredToOptional === undefined || $requiredToNonexistent === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return {
          requiredToRequired: $requiredToRequired,
          requiredToAsymmetric: $requiredToAsymmetric,
          requiredToOptional: $requiredToOptional,
          requiredToNonexistent: $requiredToNonexistent,
          asymmetricToRequired: $asymmetricToRequired,
          asymmetricToAsymmetric: $asymmetricToAsymmetric,
          asymmetricToOptional: $asymmetricToOptional,
          asymmetricToNonexistent: $asymmetricToNonexistent,
          optionalToRequired: $optionalToRequired,
          optionalToAsymmetric: $optionalToAsymmetric,
          optionalToOptional: $optionalToOptional,
          optionalToNonexistent: $optionalToNonexistent,
        };
      }

      export function outToIn(value: ExampleStructOut): ExampleStructIn {
        return value;
      }
    }

    export type ExampleChoiceOut =
      | { $field: 'requiredToRequired'; requiredToRequired: string }
      | { $field: 'requiredToAsymmetric'; requiredToAsymmetric: string }
      | { $field: 'asymmetricToRequired'; asymmetricToRequired: string; $fallback: ExampleChoiceOut }
      | { $field: 'asymmetricToAsymmetric'; asymmetricToAsymmetric: string; $fallback: ExampleChoiceOut }
      | { $field: 'asymmetricToOptional'; asymmetricToOptional: string; $fallback: ExampleChoiceOut }
      | { $field: 'asymmetricToNonexistent'; asymmetricToNonexistent: string; $fallback: ExampleChoiceOut }
      | { $field: 'optionalToRequired'; optionalToRequired: string; $fallback: ExampleChoiceOut }
      | { $field: 'optionalToAsymmetric'; optionalToAsymmetric: string; $fallback: ExampleChoiceOut }
      | { $field: 'optionalToOptional'; optionalToOptional: string; $fallback: ExampleChoiceOut }
      | { $field: 'optionalToNonexistent'; optionalToNonexistent: string; $fallback: ExampleChoiceOut };

    export type ExampleChoiceIn =
      | { $field: 'requiredToRequired'; requiredToRequired: string }
      | { $field: 'requiredToAsymmetric'; requiredToAsymmetric: string }
      | { $field: 'asymmetricToRequired'; asymmetricToRequired: string }
      | { $field: 'asymmetricToAsymmetric'; asymmetricToAsymmetric: string }
      | { $field: 'asymmetricToOptional'; asymmetricToOptional: string }
      | { $field: 'asymmetricToNonexistent'; asymmetricToNonexistent: string }
      | { $field: 'optionalToRequired'; optionalToRequired: string; $fallback: ExampleChoiceIn }
      | { $field: 'optionalToAsymmetric'; optionalToAsymmetric: string; $fallback: ExampleChoiceIn }
      | { $field: 'optionalToOptional'; optionalToOptional: string; $fallback: ExampleChoiceIn }
      | { $field: 'optionalToNonexistent'; optionalToNonexistent: string; $fallback: ExampleChoiceIn };

    export namespace ExampleChoice {
      export function size(value: ExampleChoiceOut): number {
        let payloadSize = 0;

        switch (value.$field) {
          case 'requiredToRequired': {
            const payload = value.requiredToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'requiredToAsymmetric': {
            const payload = value.requiredToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize;
          }
          case 'asymmetricToRequired': {
            const payload = value.asymmetricToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(4n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.asymmetricToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'asymmetricToOptional': {
            const payload = value.asymmetricToOptional;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'asymmetricToNonexistent': {
            const payload = value.asymmetricToNonexistent;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(7n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'optionalToRequired': {
            const payload = value.optionalToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'optionalToAsymmetric': {
            const payload = value.optionalToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(9n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'optionalToOptional': {
            const payload = value.optionalToOptional;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          case 'optionalToNonexistent': {
            const payload = value.optionalToNonexistent;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(11n, payloadSize, false) + payloadSize + size(value.$fallback);
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.$field) {
          case 'requiredToRequired': {
            const payload = value.requiredToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            return offset;
          }
          case 'requiredToAsymmetric': {
            const payload = value.requiredToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            return offset;
          }
          case 'asymmetricToRequired': {
            const payload = value.asymmetricToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.asymmetricToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'asymmetricToOptional': {
            const payload = value.asymmetricToOptional;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'asymmetricToNonexistent': {
            const payload = value.asymmetricToNonexistent;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'optionalToRequired': {
            const payload = value.optionalToRequired;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'optionalToAsymmetric': {
            const payload = value.optionalToAsymmetric;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'optionalToOptional': {
            const payload = value.optionalToOptional;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          case 'optionalToNonexistent': {
            const payload = value.optionalToNonexistent;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            offset = serialize(dataView, offset, value.$fallback);
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(dataView: DataView): ExampleChoiceIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'requiredToRequired',
                requiredToRequired: payload,
              };
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'requiredToAsymmetric',
                requiredToAsymmetric: payload,
              };
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToRequired',
                asymmetricToRequired: payload,
              };
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToAsymmetric',
                asymmetricToAsymmetric: payload,
              };
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToOptional',
                asymmetricToOptional: payload,
              };
            }
            case 7n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToNonexistent',
                asymmetricToNonexistent: payload,
              };
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'optionalToRequired',
                optionalToRequired: payload,
                $fallback,
              };
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'optionalToAsymmetric',
                optionalToAsymmetric: payload,
                $fallback,
              };
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'optionalToOptional',
                optionalToOptional: payload,
                $fallback,
              };
            }
            case 11n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserialize(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'optionalToNonexistent',
                optionalToNonexistent: payload,
                $fallback,
              };
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: ExampleChoiceOut): ExampleChoiceIn {
        return value;
      }
    }
  }

  export namespace Types {
    export type SingletonStructOut = {
      x: string;
    };

    export type SingletonStructIn = {
      x: string;
    };

    export namespace SingletonStruct {
      export function size(value: SingletonStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: SingletonStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const sourceBuffer = textEncoder.encode(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        return offset;
      }

      export function deserialize(dataView: DataView): SingletonStructIn {
        const dataViewAlias = dataView;

        let offset = 0;

        let $x;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $x = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if ($x === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return {
          x: $x,
        };
      }

      export function outToIn(value: SingletonStructOut): SingletonStructIn {
        return value;
      }
    }

    export type SingletonChoiceOut =
      | { $field: 'x'; x: string }
      | { $field: never };

    export type SingletonChoiceIn =
      | { $field: 'x'; x: string }
      | { $field: never };

    export namespace SingletonChoice {
      export function size(value: SingletonChoiceOut): number {
        let payloadSize = 0;

        switch (value.$field) {
          case 'x': {
            const payload = value.x;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: SingletonChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.$field) {
          case 'x': {
            const payload = value.x;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const sourceBuffer = textEncoder.encode(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(dataView: DataView): SingletonChoiceIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'x',
                x: payload,
              };
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: SingletonChoiceOut): SingletonChoiceIn {
        return value;
      }
    }
  }
}

export namespace Types {
}
